<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<doc>
  <assembly>
    <name>Rhino.Commons</name>
  </assembly>
  <members>
    <member name="T:Castle.ActiveRecord.AbstractValidationAttribute">
      <summary>
            The base class for all the validation attributes.
            This class define a <seealso cref="P:Castle.ActiveRecord.AbstractValidationAttribute.Validator" /> property that is used to retrieve the validtor that is used to 
            validate the value of the property.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.AbstractValidationAttribute.#ctor(Castle.ActiveRecord.Framework.IValidator)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.AbstractValidationAttribute" /> class.
            </summary>
      <param name="validator">The validator.</param>
    </member>
    <member name="M:Castle.ActiveRecord.AbstractValidationAttribute.#ctor(Castle.ActiveRecord.Framework.IValidator,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.AbstractValidationAttribute" /> class.
            </summary>
      <param name="validator">The validator.</param>
      <param name="errorMessage">The error message.</param>
    </member>
    <member name="P:Castle.ActiveRecord.AbstractValidationAttribute.Validator">
      <summary>
            Gets the validator for this attribute.
            Each attribute that inherits from this class will have its own validtor.
            </summary>
      <value>The validator.</value>
    </member>
    <member name="T:Castle.ActiveRecord.ValidateConfirmationAttribute">
      <summary>
            This it used when you need to accept two identical inputs from the user, for instnace, 
            a password and its confirmation.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateConfirmationAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateConfirmationAttribute" /> class.
            </summary>
      <param name="confirmationFieldOrProperty">The confirmation field or property that should be verified against this one.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateConfirmationAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateConfirmationAttribute" /> class.
            </summary>
      <param name="confirmationFieldOrProperty">The confirmation field or property that should be verified against this one.</param>
      <param name="errorMessage">The error message to display if this property and the configuration property are not the same.</param>
    </member>
    <member name="T:Castle.ActiveRecord.ValidateCreditCardAttribute">
      <summary>
            Properties decorated with this attribute will be validated to ensure that they represent a valid
            credit card number.
            <see ref="CreditCardValidator" /> for more details.
            </summary>
      <remarks>
            Note that this merely check the validity of the format of the value, not whatever this it an existing and valid one
            </remarks>
      <example>
            //just validate that this is a credit card of any type
            [ValidateCreditCard("You didn't fill the credit card infomration correctly.")]
            
            //Validate that this is a VISA or Discover card
            [ValidateCreditCard(CreditCardValidator.CardType.VISA | CreditCardValidator.CardType.Discover, 
            	"You need to specify a VISA or Discover card")]
            </example>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor">
      <summary>
            Initializes a new credit card validator.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(System.String)">
      <summary>
            Initializes a new credit card validator.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType)">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="allowedTypes">The card types to accept.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String)">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="allowedTypes">The card types to accept.</param>
      <param name="errorMessage">The error message to be displayed if the validation fails.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(System.String[])">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(System.String[],System.String)">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
      <param name="errorMessage">The error message to be displayed if the validation fails.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String[])">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="allowedTypes">The card types to accept.</param>
      <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateCreditCardAttribute.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String[],System.String)">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="allowedTypes">The card types to accept.</param>
      <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
      <param name="errorMessage">The error message to be displayed if the validation fails.</param>
    </member>
    <member name="T:Castle.ActiveRecord.ValidateEmailAttribute">
      <summary>
            Validate that this email address is a valid one.
            </summary>
      <remarks>
            This only check the format of the email, not if it really exists.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateEmailAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateEmailAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateEmailAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateEmailAttribute" /> class.
            </summary>
      <param name="errorMessage">The error message.</param>
    </member>
    <member name="T:Castle.ActiveRecord.ValidateIsUniqueAttribute">
      <summary>
            Validate that the property's value is unique in the database when saved
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateIsUniqueAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateIsUniqueAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateIsUniqueAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateIsUniqueAttribute" /> class.
            </summary>
      <param name="errorMessage">The error message.</param>
    </member>
    <member name="T:Castle.ActiveRecord.ValidateLengthAttribute">
      <summary>
            Validate that this property has the required length (either exact or in range)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32)">
      <summary>
            Initializes a new exact length validator.
            </summary>
      <param name="exactLength">The exact length required.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32,System.String)">
      <summary>
            Initializes a new exact length validator.
            </summary>
      <param name="exactLength">The exact length required.</param>
      <param name="errorMessage">The error message to be displayed if the validation fails.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new range based length validator.
            </summary>
      <param name="minLength">The minimum length, or <c>int.MinValue</c> if this should not be tested.</param>
      <param name="maxLength">The maximum length, or <c>int.MaxValue</c> if this should not be tested.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateLengthAttribute.#ctor(System.Int32,System.Int32,System.String)">
      <summary>
            Initializes a new range based length validator.
            </summary>
      <param name="minLength">The minimum length, or <c>int.MinValue</c> if this should not be tested.</param>
      <param name="maxLength">The maximum length, or <c>int.MaxValue</c> if this should not be tested.</param>
      <param name="errorMessage">The error message to be displayed if the validation fails.</param>
    </member>
    <member name="T:Castle.ActiveRecord.ValidateNotEmptyAttribute">
      <summary>
            Validate that the property is not null or empty (for strings)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateNotEmptyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateNotEmptyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateNotEmptyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateNotEmptyAttribute" /> class.
            </summary>
      <param name="errorMessage">The error message.</param>
    </member>
    <member name="T:Castle.ActiveRecord.ValidateRegExpAttribute">
      <summary>
            Validate that the property match the given regular expression
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateRegExpAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateRegExpAttribute" /> class.
            </summary>
      <param name="pattern">The pattern.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidateRegExpAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateRegExpAttribute" /> class.
            </summary>
      <param name="pattern">The pattern.</param>
      <param name="errorMessage">The error message.</param>
    </member>
    <member name="T:Castle.ActiveRecord.WithAccessAttribute">
      <summary>
            Base class that allows specifying an access strategy to get/set the value for an object' property.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.WithAccessAttribute.Access">
      <summary>
            Gets or sets the access strategy for this property
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.WithAccessAttribute.CustomAccess">
      <summary>
            Gets or sets the custom access strategy
            </summary>
      <value>The custom access.</value>
    </member>
    <member name="P:Castle.ActiveRecord.WithAccessAttribute.AccessString">
      <summary>
            Gets the access strategy string for NHibernate's mapping.
            </summary>
      <value>The access string.</value>
    </member>
    <member name="T:Castle.ActiveRecord.BaseAttribute">
      <summary>
            Implement common properties shared by some
            attributes
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BaseAttribute.Cache">
      <summary>
            Gets or sets the cache strategy to use for this property
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordAttribute">
      <summary>
            Associate meta information related to the
            desired table mapping.
            </summary>
      <example>
        <code>
            [ActiveRecord("tb_Order")]
            public class Order : ActiveRecordBase
            {
            }
            </code>
      </example>
      <remarks>
            If no table is specified, the class name 
            is used as table name
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor">
      <summary>
            Uses the class name as table name
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String)">
      <summary>
            Associates the specified table with the target type
            </summary>
      <param name="table">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String,System.String)">
      <summary>
            Associates the specified table and schema with the target type
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Table">
      <summary>
            Gets or sets the table name associated with the type
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Schema">
      <summary>
            Gets or sets the schema name associated with the type
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Proxy">
      <summary>
            Associates a proxy type with the target type
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorColumn">
      <summary>
            Gets or sets the Discriminator column for
            a table inheritance modeling
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorType">
      <summary>
            Gets or sets the column type (like string or integer)
            for the discriminator column
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorValue">
      <summary>
            Gets or sets the value that represents the
            target class on the discriminator column
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Where">
      <summary>
            SQL condition to retrieve objects
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Lazy">
      <summary>
            Enable lazy loading for the type
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.LazySpecified">
      <summary>
            Gets a value indicating whether explicit lazy behavior was specified.
            If explicit lazy behavior was not specified, it goes to the configuration to decide if the type should
            be lazy or not.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DynamicUpdate">
      <summary>
            From NHibernate documentation:
            Specifies that UPDATE SQL should be 
            generated at runtime and contain only 
            those columns whose values have changed.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DynamicInsert">
      <summary>
            From NHibernate documentation:
            Specifies that INSERT SQL should be 
            generated at runtime and contain only 
            the columns whose values are not null.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Persister">
      <summary>
            From NHibernate documentation:
            Specifies a custom <see cref="T:NHibernate.Persister.Entity.IEntityPersister" />.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.SelectBeforeUpdate">
      <summary>
            From NHibernate documentation:
            Specifies that NHibernate should never perform an SQL UPDATE 
            unless it is certain that an object is actually modified. In 
            certain cases (actually, only when a transient object has 
            been associated with a new session using update()), this means 
            that NHibernate will perform an extra SQL SELECT to determine 
            if an UPDATE is actually required.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Polymorphism">
      <summary>
            From NHibernate documentation:
            Determines whether implicit or explicit query polymorphism is used.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Mutable">
      <summary>
            From NHibernate documentation:
            Specifies that instances of the class are (not) mutable.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.BatchSize">
      <summary>
            From NHibernate documentation:
            Specify a "batch size" for fetching instances of 
            this class by identifier.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Locking">
      <summary>
            From NHibernate documentation:
            Determines the optimistic locking strategy.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.UseAutoImport">
      <summary>
            From NHibernate documentation:
            The auto-import attribute lets us use 
            unqualified class names in the query language, 
            by default. The assembly  and namespace attributes 
            specify the assembly where persistent classes 
            are located and the namespace they are declared in.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordSkipAttribute">
      <summary>
            Denotes that the specific class - 
            which is an <see cref="T:Castle.ActiveRecord.ActiveRecordBase" /> subclass
            should not be processed by the framework
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.AnyAttribute">
      <summary>
            This attribute is used to create &lt;any/&gt; assoication, a polymorphic assoication to classes that
            do not share a common base class.
            <example>
            Assuming we have two classes that implement IPayment, CreditCard and BankAccount, and we want a property
            that can point ot either one of them. We can map it like this:
            <code>
            [Any(typeof (long), MetaType=typeof (string),
            	TypeColumn="BILLING_DETAILS_TYPE",
            	IdColumn="BILLING_DETAILS_ID",
            	Cascade=CascadeEnum.SaveUpdate)]
            [Any.MetaValue("CREDIT_CARD", typeof (CreditCard))]
            [Any.MetaValue("BANK_ACCOUNT", typeof (BankAccount))]
            public IPayment Payment { get { ... } set { ... } }
            </code>
             The [Any] attribute specify that the id type is long, that the meta type (the type that specify the type of 
             the class) is string.
             The TypeColumn = "BILLING_DETAILS_TYPE" means that Active Record will look in this column to figure out what the type
             of the associated entity is.
             The IdColumn = "BILLING_DETAILS_ID" means that Active Record will use this column in conjuction with the type of the entity
             to find the relevant entity. This is the id of the associated entity (which can point to either back account or credit card).
             Cascade has the usual semantics.
             
             [Any.MetaValue("CREDIT_CARD", typeof (CreditCard))] - means that when Active Record encounters a "CREDIT_CARD" value in 
             the "BILLING_DETAILS_TYPE", is assumes that the id in the "BILLING_DETAILS_ID" is the id of a CreditCard entity.
             
             [Any.MetaValue("BANK_ACCOUNT", typeof (BankAccount))] - same, just for "BANK_ACCOUNT" meaning that the id in "BILLING_DETAILS_ID"
             is an id of a bank account.
             </example></summary>
      <remarks>
            This is supplied for advanced sceanrios.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.AnyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.AnyAttribute" /> class.
            </summary>
      <remarks>Using this constructor defaults the idType to Int32</remarks>
    </member>
    <member name="M:Castle.ActiveRecord.AnyAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.AnyAttribute" /> class.
            </summary>
      <param name="idType">Type of the id.</param>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.IdType">
      <summary>
            Gets or sets the type of the id.
            </summary>
      <value>The type of the id.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.MetaType">
      <summary>
            Gets or sets the type of the meta column
            </summary>
      <value>The type of the meta.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.Cascade">
      <summary>
            Gets or sets the cascade options
            </summary>
      <value>The cascade.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.TypeColumn">
      <summary>
            Gets or sets the type column name
            </summary>
      <value>The type column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.IdColumn">
      <summary>
            Gets or sets the id column name
            </summary>
      <value>The id column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.Index">
      <summary>
            Gets or sets the index column name
            </summary>
      <value>The index.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.Insert">
      <summary>
            Gets or sets a value indicating whether the column should be inserted when inserting.
            </summary>
      <value>
        <c>true</c> if should insert; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.Update">
      <summary>
            Gets or sets a value indicating whether the column should be is updated when updating.
            </summary>
      <value>
        <c>true</c> if should update; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.AnyAttribute.NotNull">
      <summary>
            Gets or sets a value indicating whether this property cannot be null.
            </summary>
      <value>
        <c>true</c> if this property cannot be null; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Any">
      <summary>
            Avoids the AnyAttribute.MetaValue syntax
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Any.MetaValueAttribute">
      <summary>
            This is used to specify a meta value in an [Any] assoication
            Any.MetaValue is used to connect a value (such as "CREDIT_CARD") to its type ( typeof(CreditCard) ).
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Any.MetaValueAttribute.#ctor(System.String,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Any.MetaValueAttribute" /> class.
            </summary>
      <param name="value">The value.</param>
      <param name="clazz">The clazz.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Any.MetaValueAttribute.Value">
      <summary>
            Gets or sets the value for this class
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Any.MetaValueAttribute.Class">
      <summary>
            Gets or sets the class that match this value
            </summary>
      <value>The class.</value>
    </member>
    <member name="T:Castle.ActiveRecord.NotFoundBehaviour">
      <summary>
            Define how broken relations should be handled.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.NotFoundBehaviour.Default">
      <summary>
            Throw an exception when the relation is broken.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.NotFoundBehaviour.Exception">
      <summary>
            Throw an exception when the relation is broken.
            </summary>
      <remarks>this is the default behaviour</remarks>
    </member>
    <member name="F:Castle.ActiveRecord.NotFoundBehaviour.Ignore">
      <summary>
            Ignore the broken relation and update
            the FK to null on the next save.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.BelongsToAttribute">
      <summary>
            Maps a one to one association.
            </summary>
      <example>
        <code>
            public class Post : ActiveRecordBase
            {
            		...
            
            		[BelongsTo("blogid")]
            		public Blog Blog
            		{
            		get { return _blog; }
            		set { _blog = value; }
            		}
            	</code>
      </example>
      <remarks>
            Please note that the 'blogid' foreign key lies on the 'Post' table.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.BelongsToAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.BelongsToAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.BelongsToAttribute.#ctor(System.String)">
      <summary>
            Indicates the name of the column to be used on the association.
            Usually the name of the foreign key field on the underlying database.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.Type">
      <summary>
            Defines the target type of the association. It's usually inferred from the property type.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.Column">
      <summary>
            Defines the column used by association (usually a foreign key)
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.CompositeKeyColumns">
      <summary>
            Defines the Composite Key columns used by association (aka Natural Keys).
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.Cascade">
      <summary>
            Defines the cascading behavior of this association.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.OuterJoin">
      <summary>
            Defines the outer join behavior of this association.
            NHibernate has deprecated the outer-join attribute so this property is
            marked obsolete - it now converts to and from the fetch value.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.Fetch">
      <summary>
            Chooses between outer-join fetching
            or sequential select fetching.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.Update">
      <summary>
            Set to <c>false</c> to ignore this association when updating entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.Insert">
      <summary>
            Set to <c>false</c> to ignore this association when inserting entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.NotNull">
      <summary>
            Indicates whether this association allows nulls or not.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.Unique">
      <summary>
            Indicates whether this association is unique.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.NotFoundBehaviour">
      <summary>
            Gets or sets the way broken relations are handled.
            </summary>
      <value>The behaviour.</value>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.UniqueKey">
      <summary>
            From NHibernate documentation:
            A unique-key attribute can be used to group columns 
            in a single unit key constraint. 
            </summary>
      <value>unique key name</value>
      <remarks>
            Currently, the 
            specified value of the unique-key attribute is not 
            used to name the constraint, only to group the columns 
            in the mapping file.
            </remarks>
    </member>
    <member name="P:Castle.ActiveRecord.BelongsToAttribute.ForeignKey">
      <summary>
            Gets and sets the name of the foreign key constraint 
            generated for an association.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.CollectionIDType">
      <summary>
            Defines the values for the generator for the Collection Id values.w
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.Identity">
      <summary>
            Use Identity column (auto number)
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.Sequence">
      <summary>
            Use a sequence
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.HiLo">
      <summary>
            Use the HiLo algorithm to get the next value
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.SeqHiLo">
      <summary>
            Use a sequence and a HiLo algorithm - better performance on Oracle
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.UuidHex">
      <summary>
            Use the hex representation of a unique identifier
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.UuidString">
      <summary>
            Use the string representation of a unique identifier
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.Guid">
      <summary>
            Generate a Guid for the primary key
            Note: You should prefer using GuidComb over this value.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.GuidComb">
      <summary>
            Generate a Guid in sequence, so it will have better insert performance in the DB.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.Assigned">
      <summary>
            The key value is always assigned.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CollectionIDType.Foreign">
      <summary>
            This is a foreign key to another table
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.CollectionIDAttribute">
      <summary>
            Used for a collection that requires a collection id.
            </summary>
      <example>
        <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany]
            	[CollectionIDAttribute(CollectionIDAttribute.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code>
      </example>
    </member>
    <member name="M:Castle.ActiveRecord.CollectionIDAttribute.#ctor(Castle.ActiveRecord.CollectionIDType,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.CollectionIDAttribute" /> class.
            </summary>
      <param name="generator">The generator.</param>
      <param name="column">The column.</param>
      <param name="ColumnType">Type of the column.</param>
    </member>
    <member name="P:Castle.ActiveRecord.CollectionIDAttribute.Generator">
      <summary>
            Gets or sets the generator.
            </summary>
      <value>The generator.</value>
    </member>
    <member name="P:Castle.ActiveRecord.CollectionIDAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.CollectionIDAttribute.ColumnType">
      <summary>
            Gets or sets the type of the column.
            </summary>
      <value>The type of the column.</value>
    </member>
    <member name="T:Castle.ActiveRecord.CompositeKeyAttribute">
      <summary>
            Defines that the target property is a composite key
            for the scope class
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.CompositeKeyAttribute.UnsavedValue">
      <summary>
            Gets or sets the unsaved value.
            </summary>
      <value>The unsaved value.</value>
    </member>
    <member name="T:Castle.ActiveRecord.CompositeUserTypeAttribute">
      <summary>
            Maps the property to db using a NHibernate's <see cref="T:NHibernate.UserTypes.ICompositeUserType" />.
            </summary>
      <remarks>
            You should specify the column names and the ICompositeUserType implementor.
            </remarks>
      <example>
        <code>
            	[CompositeUserType(typeof(DoubleStringType), new string[] {"Product_FirstName", "Product_LastName"})]
            	public string[] Name
            	{
            		get { return name; }
            		set { name = value; }
            	}
            </code>
            or 
            <code>
            	[CompositeUserType(
            		typeof(DoubleStringType), 
            		new string[]{"Manufacturer_FirstName", "Manufacturer_LastName"}, 
            		Length = new int[] {4, 5} )]
            	public string[] ManufacturerName
            	{
            		get { return manufacturerName; }
            		set { manufacturerName = value; }
            	}
            </code></example>
    </member>
    <member name="M:Castle.ActiveRecord.CompositeUserTypeAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.CompositeUserTypeAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.CompositeUserTypeAttribute.#ctor(System.Type,System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.CompositeUserTypeAttribute" /> class.
            </summary>
      <param name="compositeType">Type of the ICompositeUserType implmentor.</param>
      <param name="columnNames">The column names.</param>
    </member>
    <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.CompositeType">
      <summary>
            Gets or sets the type of the ICompositeUserType implementor.
            </summary>
      <value>The type of the composite.</value>
    </member>
    <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.ColumnNames">
      <summary>
            Gets or sets the column names.
            </summary>
      <value>The column names.</value>
    </member>
    <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.Length">
      <summary>
            Gets or sets the length of the columns.
            </summary>
      <value>The columns length.</value>
    </member>
    <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.Update">
      <summary>
            Set to <c>false</c> to ignore this property when updating entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.Insert">
      <summary>
            Set to <c>false</c> to ignore this property when inserting entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.OptimisticLocking">
      <summary>
            Defines the values for optimistic locking
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OptimisticLocking.None">
      <summary>
            do not use optimistic locking
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OptimisticLocking.Version">
      <summary>
            check the version/timestamp columns
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OptimisticLocking.Dirty">
      <summary>
            check the changed columns
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OptimisticLocking.All">
      <summary>
            check all columns
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Polymorphism">
      <summary>
            Define the polymorphism options
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Polymorphism.Implicit">
      <summary>
            Implicit polymorphism
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Polymorphism.Explicit">
      <summary>
            Explicit polymorphism
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.CacheEnum">
      <summary>
            Define the caching options
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CacheEnum.Undefined">
      <summary>
            Default value, no caching
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CacheEnum.ReadOnly">
      <summary>
            Read only cache - use for cases where no write are performed.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CacheEnum.ReadWrite">
      <summary>
            Read write cache
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CacheEnum.NonStrictReadWrite">
      <summary>
            Read write cache with looser semantics.
            Check NHibernate's documentation for the detials.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.OuterJoinEnum">
      <summary>
            Define outer join options
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OuterJoinEnum.Auto">
      <summary>
            Let NHibernate decide what to do
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OuterJoinEnum.True">
      <summary>
            Use outer join
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OuterJoinEnum.False">
      <summary>
            Do not use outer join
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.FetchEnum">
      <summary>
            Define the possible fetch option values
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.FetchEnum.Unspecified">
      <summary>
            Let NHibernate decide what to do here
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.FetchEnum.Join">
      <summary>
            Use a JOIN to load the data
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.FetchEnum.Select">
      <summary>
            Use a seperate SELECT statement to load the data
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.CascadeEnum">
      <summary>
            Defines the cascading behaviour of this association.
            </summary>
      <remarks>
            Entities has associations to other objects, this may be an association to a single item (<see cref="T:Castle.ActiveRecord.BelongsToAttribute" />)
            or an association to a collection (<see cref="T:Castle.ActiveRecord.HasManyAttribute" />, <see cref="T:Castle.ActiveRecord.HasManyToAnyAttribute" />).
            At any rate, you are able to tell NHibernate to automatically traverse an entity's associations, and act according 
            to the cascade option. For instance, adding an unsaved entity to a collection with <see cref="F:Castle.ActiveRecord.CascadeEnum.SaveUpdate" />
            cascade will cause it to be saved along with its parent object, without any need for explicit instructions on our side.
            </remarks>
    </member>
    <member name="F:Castle.ActiveRecord.CascadeEnum.None">
      <summary>
            No cascading. This is the default.
            The cascade should be handled manually.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CascadeEnum.All">
      <summary>
            Cascade save, update and delete.
            When the object is saved, updated or deleted, the associations will be checked
            and the objects found will also be saved, updated or deleted.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CascadeEnum.SaveUpdate">
      <summary>
            Cascade save and update.
            When the object is saved or updated, the associations will be checked and any object that requires
            will be saved or updated (including saving or updating the associations in many-to-many scenario).
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.CascadeEnum.Delete">
      <summary>
            Cascade delete.
            When the object is deleted, all the objects in the association will be deleted as well.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ManyRelationCascadeEnum">
      <summary>
            Defines the cascading behaviour of this association.
            </summary>
      <remarks>
            Entities has associations to other objects, this may be an association to a single item (<see cref="T:Castle.ActiveRecord.BelongsToAttribute" />)
            or an association to a collection (<see cref="T:Castle.ActiveRecord.HasManyAttribute" />, <see cref="T:Castle.ActiveRecord.HasManyToAnyAttribute" />).
            At any rate, you are able to tell NHibernate to automatically traverse an entity's associations, and act according 
            to the cascade option. For instance, adding an unsaved entity to a collection with <see cref="F:Castle.ActiveRecord.CascadeEnum.SaveUpdate" />
            cascade will cause it to be saved along with its parent object, without any need for explicit instructions on our side.
            </remarks>
    </member>
    <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.None">
      <summary>
            No cascading. This is the default.
            The cascade should be handled manually.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.All">
      <summary>
            Cascade save, update and delete.
            When the object is saved, updated or deleted, the associations will be checked
            and the objects found will also be saved, updated or deleted.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.SaveUpdate">
      <summary>
            Cascade save and update.
            When the object is saved or updated, the associations will be checked and any object that requires
            will be saved or updated (including saving or updating the associations in many-to-many scenario).
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.Delete">
      <summary>
            Cascade delete.
            When the object is deleted, all the objects in the association will be deleted as well.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.AllDeleteOrphan">
      <summary>
            Cascade save, update and delete, removing orphan children.
            When an object is saved, updated or deleted, the associations will be checked and all objects found
            will be saved, updated or deleted as well.
            In additional to that, when an object is removed from the association and not associated with another object (orphaned), it will also be deleted.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.FieldAttribute">
      <summary>
            Maps a standard column of the table.
            </summary>
      <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	[Field]
            	string name;
            	
            	
            </code></example>
    </member>
    <member name="M:Castle.ActiveRecord.FieldAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.FieldAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.FieldAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.FieldAttribute" /> class.
            </summary>
      <param name="column">The column name.</param>
    </member>
    <member name="M:Castle.ActiveRecord.FieldAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.FieldAttribute" /> class.
            </summary>
      <param name="column">The column name</param>
      <param name="type">The column type.</param>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.NotNull">
      <summary>
            Gets or sets a value indicating whether the column allows null values
            </summary>
      <value>
        <c>true</c> if [not null]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Length">
      <summary>
            Gets or sets the length of this column. char(10), etc
            </summary>
      <value>The length.</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.UniqueKey">
      <summary>
            From NHibernate documentation:
            A unique-key attribute can be used to group columns 
            in a single unit key constraint. 
            </summary>
      <value>unique key name</value>
      <remarks>
            Currently, the 
            specified value of the unique-key attribute is not 
            used to name the constraint, only to group the columns 
            in the mapping file.
            </remarks>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Index">
      <summary>
            From NHibernate documentation:
            specifies the name of a (multi-column) index
            </summary>
      <value>index name</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.SqlType">
      <summary>
            From NHibernate documentation:
            overrides the default column type
            </summary>
      <value>column_type</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Check">
      <summary>
            From NHibernate documentation:
            create an SQL check constraint on either column or table
            </summary>
      <value>Sql Expression</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Update">
      <summary>
            Set to <c>false</c> to ignore this 
            field when updating entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Insert">
      <summary>
            Set to <c>false</c> to ignore this 
            field when inserting entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Unique">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.FieldAttribute" /> is unique.
            </summary>
      <value>
        <c>true</c> if unique; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.Formula">
      <summary>
            Gets or sets the formula used to calculate this field
            </summary>
      <value>The formula.</value>
    </member>
    <member name="P:Castle.ActiveRecord.FieldAttribute.ColumnType">
      <summary>
            Gets or sets the type of the column.
            </summary>
      <value>The type of the column.</value>
    </member>
    <member name="T:Castle.ActiveRecord.RelationAttribute">
      <summary>
            Base class to define common relation information
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.RelationType">
      <summary>
            Gets or sets the type of the relation.
            </summary>
      <value>The type of the relation.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.MapType">
      <summary>
            Gets or sets the type of the map.
            </summary>
      <value>The type of the map.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Table">
      <summary>
            Gets or sets the table for this relation
            </summary>
      <value>The table.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Schema">
      <summary>
            Gets or sets the schema for this relation (dbo., etc)
            </summary>
      <value>The schema.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Lazy">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.RelationAttribute" /> is lazy.
            </summary>
      <value>
        <c>true</c> if lazy; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Inverse">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.RelationAttribute" /> is inverse.
            </summary>
      <value>
        <c>true</c> if inverse; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Cascade">
      <summary>
            Gets or sets the cascade options for this <see cref="T:Castle.ActiveRecord.RelationAttribute" /></summary>
      <value>The cascade.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.OrderBy">
      <summary>
            Gets or sets the order by clause for this relation
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Where">
      <summary>
            Gets or sets the where clause for this relation
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Sort">
      <summary>
            Only used with sets
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Index">
      <summary>
            Only used with maps or list
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.IndexType">
      <summary>
            Only used with maps
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.Element">
      <summary>
            Use for simple types.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.NotFoundBehaviour">
      <summary>
            Gets or sets the way broken relations are handled.
            </summary>
      <value>The behaviour.</value>
    </member>
    <member name="P:Castle.ActiveRecord.RelationAttribute.BatchSize">
      <summary>
            From NHibernate documentation:
            Specify a "batch size" for batch fetching of collections.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute">
      <summary>
            Maps a many to many association with an association table.
            </summary>
      <example>
        <code>
            public class Company : ActiveRecordBase
            {
              ...
              
              [HasAndBelongsToMany( typeof(Person), RelationType.Bag, Table="PeopleCompanies", Column="person_id", ColumnKey="company_id" )]
              public IList People
              {
              	get { return _people; }
              	set { _people = value; }
              }
            }
            </code>
      </example>
      <remarks>The <see cref="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnKey" /> must specify the key on the 
            association table that points to the primary key of this class. In 
            the example, 'company_id' points to 'Company'.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.HasAndBelongsToManyAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute" /> class.
            </summary>
      <param name="mapType">Type of the map.</param>
    </member>
    <member name="M:Castle.ActiveRecord.HasAndBelongsToManyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.HasAndBelongsToManyAttribute.#ctor(System.Type,Castle.ActiveRecord.RelationType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute" /> class.
            </summary>
      <param name="mapType">Type of the map.</param>
      <param name="type">The type.</param>
    </member>
    <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnRef">
      <summary>
            Gets or sets the column that represent the other side on the assoication table
            </summary>
      <value>The column ref.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.CompositeKeyColumnRefs">
      <summary>
            Gets or sets the composite key columns that represent the other side on the assoication table
            </summary>
      <value>The composite key column refs.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnKey">
      <summary>
            Gets or sets the key column name
            </summary>
      <value>The column key.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.CompositeKeyColumnKeys">
      <summary>
            Gets or sets the composite key columns names.
            </summary>
      <value>The composite key column keys.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.Fetch">
      <summary>
            Chooses between outer-join fetching
            or sequential select fetching.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.HasManyAttribute">
      <summary>
            Maps a one to many association.
            </summary>
      <example>
        <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasMany(typeof(Post), RelationType.Bag, ColumnKey="Posts", Table="Posts")]
            	public IList Posts
            	{
            		get { return _posts; }
            		set { _posts = value; }
            	}
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.HasManyAttribute.keyColumn">
      <summary>
            The key column
            Cannot exist if compositeKeyColumns has a value
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.HasManyAttribute.compositeKeyColumns">
      <summary>
            The composite columns
            Cannot exist with keyColumn != null
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.HasManyAttribute.hasDependentObjects">
      <summary>
            Whether the target type is for dependent objects or not
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.HasManyAttribute.fetchMethod">
      <summary>
            Whether we do outer join fetching for this collection
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.HasManyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.HasManyAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyAttribute" /> class.
            </summary>
      <param name="mapType">Type of the map.</param>
    </member>
    <member name="M:Castle.ActiveRecord.HasManyAttribute.#ctor(System.Type,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyAttribute" /> class.
            </summary>
      <param name="mapType">Type of items in this association</param>
      <param name="keyColumn">The key column.</param>
      <param name="table">The table.</param>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyAttribute.ColumnKey">
      <summary>
            Gets or sets the key column name.
            </summary>
      <value>The column key.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyAttribute.CompositeKeyColumnKeys">
      <summary>
            Gets or sets the names of the column in composite key scenarios.
            </summary>
      <value>The composite key column keys.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyAttribute.DependentObjects">
      <summary>
            Whether or not the target type is a dependent object.
            </summary>
      <value>true = the target type is a dependent object</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyAttribute.Fetch">
      <summary>
            Chooses between outer-join fetching
            or sequential select fetching.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.HasManyToAnyAttribute">
      <summary>
            This attribute allows polymorphic association between classes that doesn't have a common root class.
            In require two columns that would tell it what is the type of the asssoicated entity, and what is the PK of that entity.
            <remarks>
            This is supplied for advanced sceanrios.
            </remarks><example>
            For instnace, let assume that you have two classes (that implement a common interface, but have no base classs) called:
             - Back Account
             - Credit Card
            
            And you have a set of Payment methods, that can be either. You would define the mapping so:
            <code>
            [HasManyToAny(typeof(IPayment), "pay_id", "payments_table", typeof(int), "payment_type", "payment_method_id",
            	MetaType = typeof(int), RelationType = RelationType.Set)]
            </code>
            typeof(IPayement) - the common interface tha both classes implement, and the type of all the items in the set.
            "pay_id" - the column that hold the PK of this entity (the FK column)
            "payments_table" - the table that has the assoication information (in 1:M scenarios - usuaully the same table, in M:N scenarios the link table).
            typeof(int) - the type of id column 
            "payment_type" - the column used to find out which class is represented by this row.
            "payment_method_id" - the column that holds the PK of the assoicated class (either CreditCard or BankAccount).
            MetaType = typeof(int) - the type of the meta column (payment_type)
            RelationType = RelationType.Set - specify that we use a set here
            </example></summary>
    </member>
    <member name="M:Castle.ActiveRecord.HasManyToAnyAttribute.#ctor(System.Type,System.String,System.String,System.Type,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyToAnyAttribute" /> class.
            </summary>
      <param name="mapType">Type of the map.</param>
      <param name="keyColum">The key colum.</param>
      <param name="table">The table.</param>
      <param name="idType">Type of the id.</param>
      <param name="typeColumn">The type column.</param>
      <param name="idColumn">The id column.</param>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.TypeColumn">
      <summary>
            Gets or sets the type column.
            </summary>
      <value>The type column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.IdColumn">
      <summary>
            Gets or sets the id column.
            </summary>
      <value>The id column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.MetaType">
      <summary>
            Gets or sets the type of the meta column
            </summary>
      <value>The type of the meta.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.IdType">
      <summary>
            Gets or sets the type of the id column
            </summary>
      <value>The type of the id.</value>
    </member>
    <member name="T:Castle.ActiveRecord.HiloAttribute">
      <summary>
            Used when a constraint requires a hilo algorithm 
            </summary>
      <example>
        <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany,
            	CollectionID(CollectionIDAttribute.HiLo),
            	Hilo]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code>
      </example>
    </member>
    <member name="M:Castle.ActiveRecord.HiloAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HiloAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.HiloAttribute.#ctor(System.String,System.String,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HiloAttribute" /> class.
            </summary>
      <param name="table">The table.</param>
      <param name="column">The column.</param>
      <param name="maxlo">The maxlo.</param>
    </member>
    <member name="P:Castle.ActiveRecord.HiloAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HiloAttribute.Table">
      <summary>
            Gets or sets the table name
            </summary>
      <value>The table.</value>
    </member>
    <member name="P:Castle.ActiveRecord.HiloAttribute.MaxLo">
      <summary>
            Gets or sets the max low value
            </summary>
      <value>The max lo.</value>
    </member>
    <member name="T:Castle.ActiveRecord.HqlNamedQueryAttribute">
      <summary>
            This is used to define a named HQL query.
            It represents the &lt;query&gt; element.
            </summary>
      <example>
            [assemly: HqlNamedQuery("allAdultUsers", "from User where user.Age &gt; 21")]
            </example>
    </member>
    <member name="M:Castle.ActiveRecord.HqlNamedQueryAttribute.#ctor(System.String,System.String)">
      <summary>
            Create a new instance
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.HqlNamedQueryAttribute.Name">
      <summary>
            The name of the query
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.HqlNamedQueryAttribute.Query">
      <summary>
            The query itself
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ImportAttribute">
      <summary>
            This is used to map between a type to a friendly name that can be used in the queries.
            
            This attribute is representing an &lt;import/&gt; in the mapping files
            </summary>
      <example>
            [Import(typeof(SummaryRow), "summary")]
            </example>
    </member>
    <member name="M:Castle.ActiveRecord.ImportAttribute.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ImportAttribute" /> class.
            </summary>
      <param name="type">The type.</param>
      <param name="rename">The rename.</param>
    </member>
    <member name="P:Castle.ActiveRecord.ImportAttribute.Type">
      <summary>
            Gets the type that is being imported
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Castle.ActiveRecord.ImportAttribute.Rename">
      <summary>
            Gets or sets the renamed string that will replace the full type name in HQL queries for the specified type.
            </summary>
      <value>The renamed value.</value>
    </member>
    <member name="T:Castle.ActiveRecord.JoinedBaseAttribute">
      <summary>
            Denotes that a class is the parent class of one or 
            more subclasses using a join
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.JoinedKeyAttribute">
      <summary>
            Used for joined subclasses.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.JoinedKeyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.JoinedKeyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.JoinedKeyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.JoinedKeyAttribute" /> class.
            </summary>
      <param name="column">The column.</param>
    </member>
    <member name="P:Castle.ActiveRecord.JoinedKeyAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="T:Castle.ActiveRecord.PropertyAttribute">
      <summary>
            Maps a standard column of the table.
            </summary>
      <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[Property]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code>
            To map a column name, use 
            <code>
            	[Property("blog_name")]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code></example>
    </member>
    <member name="M:Castle.ActiveRecord.PropertyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PropertyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.PropertyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PropertyAttribute" /> class.
            </summary>
      <param name="column">The column.</param>
    </member>
    <member name="M:Castle.ActiveRecord.PropertyAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PropertyAttribute" /> class.
            </summary>
      <param name="column">The column.</param>
      <param name="type">The type.</param>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.NotNull">
      <summary>
            Gets or sets a value indicating whether this property allow null.
            </summary>
      <value>
        <c>true</c> if allow null; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Length">
      <summary>
            Gets or sets the length of the property (for strings - nvarchar(50) )
            </summary>
      <value>The length.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Update">
      <summary>
            Set to <c>false</c> to ignore this property when updating entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Insert">
      <summary>
            Set to <c>false</c> to ignore this property when inserting entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Unique">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.PropertyAttribute" /> is unique.
            </summary>
      <value>
        <c>true</c> if unique; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Formula">
      <summary>
            Gets or sets the formula used to calculate this property
            </summary>
      <value>The formula.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.ColumnType">
      <summary>
            Gets or sets the type of the column.
            </summary>
      <value>The type of the column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.UniqueKey">
      <summary>
            From NHibernate documentation:
            A unique-key attribute can be used to group columns 
            in a single unit key constraint. 
            </summary>
      <value>unique key name</value>
      <remarks>
            Currently, the 
            specified value of the unique-key attribute is not 
            used to name the constraint, only to group the columns 
            in the mapping file.
            </remarks>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Index">
      <summary>
            From NHibernate documentation:
            specifies the name of a (multi-column) index
            </summary>
      <value>index name</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.SqlType">
      <summary>
            From NHibernate documentation:
            overrides the default column type
            </summary>
      <value>column_type</value>
    </member>
    <member name="P:Castle.ActiveRecord.PropertyAttribute.Check">
      <summary>
            From NHibernate documentation:
            create an SQL check constraint on either column or table
            </summary>
      <value>Sql Expression</value>
    </member>
    <member name="T:Castle.ActiveRecord.KeyPropertyAttribute">
      <summary>
            A key property for a composite key
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.KeyPropertyAttribute.UnsavedValue">
      <summary>
            Gets or sets the unsaved value.
            </summary>
      <value>The unsaved value.</value>
    </member>
    <member name="T:Castle.ActiveRecord.NestedAttribute">
      <summary>
            Maps properties of a child object to columns of the table 
            of a parent class.
            </summary>
      <example>
            The following code illustrates the use of a 
            nested <c>PostalAddress</c> class
            <code>
            	[ActiveRecord("Companies")]
            	public class Company : ActiveRecordBase
            	{
            		private int id;
            		private PostalAddress _address;
            	
            		public Company()
            		{
            		}
            	
            		public Company(string name)
            		{
            			this.name = name;
            		}
            	
            		[PrimaryKey]
            		public int Id
            		{
            			get { return id; }
            			set { id = value; }
            		}
            	
            		[Nested]
            		public PostalAddress Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	}
            	
            	public class PostalAddress
            	{
            		private String _address;
            		private String _city;
            		private String _state;
            		private String _zipcode;
            	
            		[Property]
            		public String Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	
            		[Property]
            		public String City
            		{
            			get { return _city; }
            			set { _city = value;}
            		}
            	
            		[Property]
            		public String State
            		{
            			get { return _state; }
            			set { _state = value; }
            		}
            	
            		[Property]
            		public String ZipCode
            		{
            			get { return _zipcode; }
            			set { _zipcode = value; }
            		}
            	}
            </code></example>
    </member>
    <member name="M:Castle.ActiveRecord.NestedAttribute.#ctor">
      <summary>
            Informs ActiveRecord that the marked property contains nested elements, contained
            in a separate, reusable class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.NestedAttribute.#ctor(System.String)">
      <summary>
            Informs ActiveRecord that the marked property contains nested elements, contained
            in a separate, reusable class.
            </summary>
      <param name="columnPrefix">A prefix to insert before each column in the nested component</param>
    </member>
    <member name="P:Castle.ActiveRecord.NestedAttribute.MapType">
      <summary>
            Allows one to reference a different type
            than the property type
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.NestedAttribute.Update">
      <summary>
            Set to <c>false</c> to ignore this nested component when updating entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.NestedAttribute.Insert">
      <summary>
            Set to <c>false</c> to ignore this nested component when inserting entities of this ActiveRecord class.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.NestedAttribute.ColumnPrefix">
      <summary>
            A prefix to insert before each column in the nested component.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.NestedParentReferenceAttribute">
      <summary>
             Maps a property of a child object to its parent object.
             </summary>
      <example>
             The following code illustrates the use of a 
             parent <c>Company</c> class
             <code>
                 public class PostalAddress
             	{
                     private Company _company;
             		private String _address;
             		private String _city;
             		private String _state;
             		private String _zipcode;
             	
                     [Parent]
                     public Company Parent
                     {
                         get { return _company; }
                         set { _company = value; }
                     }
            
             		[Property]
             		public String Address
             		{
             			get { return _address; }
             			set { _address = value; }
             		}
             	
             		[Property]
             		public String City
             		{
             			get { return _city; }
             			set { _city = value;}
             		}
             	
             		[Property]
             		public String State
             		{
             			get { return _state; }
             			set { _state = value; }
             		}
             	
             		[Property]
             		public String ZipCode
             		{
             			get { return _zipcode; }
             			set { _zipcode = value; }
             		}
             	}
            
             	[ActiveRecord("Companies")]
             	public class Company : ActiveRecordBase
             	{
             		private int id;
             		private PostalAddress _address;
             	
             		public Company()
             		{
             		}
             	
             		public Company(string name)
             		{
             			this.name = name;
             		}
             	
             		[PrimaryKey]
             		public int Id
             		{
             			get { return id; }
             			set { id = value; }
             		}
             	
             		[Nested]
             		public PostalAddress Address
             		{
             			get { return _address; }
             			set { _address = value; }
             		}
             	}
             </code></example>
    </member>
    <member name="M:Castle.ActiveRecord.NestedParentReferenceAttribute.#ctor">
      <summary>
            Informs ActiveRecord that the marked property is the parent of a nested element
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.OneToOneAttribute">
      <summary>
            Associates a foreign table where the current class
            and the target class share their primary key.
            </summary>
      <example>
            The following code exemplifies two classes that maps 
            to two tables sharing the primary key:
            <code>
            	[ActiveRecord("Employee")]
            	public class Employee : ActiveRecordBase
            	{
            		private int id;
            		private Award award;
            	
            		[PrimaryKey(PrimaryKeyType.Native, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		[OneToOne]
            		public Award Award
            		{
            			get { return this.award; }
            			set { this.award = value; }
            		}
            	}
            	
            	[ActiveRecord("Award")]
            	public class Award : ActiveRecordBase
            	{
            		private Employee employee;
            		private int id;
            	
            		public Award()
            		{
            		}
            	
            		public Award(Employee employee)
            		{
            			this.employee = employee;
            		}
            	
            		[OneToOne]
            		public Employee Employee
            		{
            			get { return this.employee; }
            			set { this.employee = value; }
            		}
            	
            		[PrimaryKey(PrimaryKeyType.Foreign, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		public static Award[] FindAll()
            		{
            			return ((Award[]) (ActiveRecordBase.FindAll(typeof(Award))));
            		}
            	
            		public static void DeleteAll()
            		{
            			ActiveRecordBase.DeleteAll( typeof(Award) );
            		}
            	}
            	Employee emp = new Employee();
            	emp.Name = "john doe";
            	emp.Save();
            	
            	Award award = new Award(emp);
            	award.Description = "Invisible employee";
            	award.Save();
            </code></example>
      <remarks>
            Usually classes that uses the primary key
            generated elsewhere (foreign) uses the PrimaryKey attribute with the
            generator type <c>PrimaryKeyType.Foreign</c></remarks>
    </member>
    <member name="P:Castle.ActiveRecord.OneToOneAttribute.MapType">
      <summary>
            Allows one to reference a different type
            than the property type
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.OneToOneAttribute.Cascade">
      <summary>
            From NHibernate docs: specifies which operations should be 
            cascaded from the parent object to the associated object.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.OneToOneAttribute.Fetch">
      <summary>
            From NHibernate docs: Chooses between outer-join fetching 
            or sequential select fetching.
            </summary>
      <remarks>
            Defaults to <see cref="F:Castle.ActiveRecord.FetchEnum.Select" /></remarks>
    </member>
    <member name="P:Castle.ActiveRecord.OneToOneAttribute.PropertyRef">
      <summary>
            From NHibernate docs: The name of a property of the 
            associated class that is joined to the primary key 
            of this class. If not specified, the primary key of 
            the associated class is used.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.OneToOneAttribute.Constrained">
      <summary>
            From NHibernate docs: specifies that a foreign key 
            constraint on the primary key of the mapped table 
            references the table of the associated class. 
            This option affects the order in which Save() and 
            Delete() are cascaded (and is also used by the 
            schema export tool).
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.OneToOneAttribute.ForeignKey">
      <summary>
            Gets or sets the name of the foreign key constraint generated for 
            an association. NHibernate will only use the ForeignKey name one 
            the inherited class and Constrained = true.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.PrimaryKeyType">
      <summary>
            Define the possible strategies to set the Primary Key values
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Identity">
      <summary>
            Use Identity column (auto number)
            Note: This force an immediate call to the DB when Create() is called
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Sequence">
      <summary>
            Use a sequence
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.HiLo">
      <summary>
            Use the HiLo algorithm to get the next value
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.SeqHiLo">
      <summary>
            Use a sequence and a HiLo algorithm - better performance on Oracle
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.UuidHex">
      <summary>
            Use the hex representation of a unique identifier
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.UuidString">
      <summary>
            Use the string representation of a unique identifier
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Guid">
      <summary>
            Generate a Guid for the primary key
            Note: You should prefer using GuidComb over this value.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.GuidComb">
      <summary>
            Generate a Guid in sequence, so it will have better insert performance in the DB.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Native">
      <summary>
            Use an identity or sequence if supported by the database, otherwise, use the HiLo algorithm
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Assigned">
      <summary>
            The primary key value is always assigned.
            Note: using this you will lose the ability to call Save(), and will need to call Create() or Update()
            explicitly.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Foreign">
      <summary>
            This is a foreign key to another table
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Counter">
      <summary>
            Returns a <c>Int64</c> constructed from the system
            time and a counter value.
            </summary>
      <remarks>
            Not safe for use in a clustser
            </remarks>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Increment">
      <summary>
            Returns a <c>Int64</c>, constructed by counting from 
            the maximum primary key value at startup. 
            </summary>
      <remarks>
            Not safe for use in a cluster
            </remarks>
    </member>
    <member name="F:Castle.ActiveRecord.PrimaryKeyType.Custom">
      <summary>
            A custom generator will be provided. See <see cref="P:Castle.ActiveRecord.PrimaryKeyAttribute.CustomGenerator" /></summary>
    </member>
    <member name="T:Castle.ActiveRecord.PrimaryKeyAttribute">
      <summary>
            Indicates the property which is the primary key.
            </summary>
      <example>
        <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[PrimaryKey(PrimaryKeyType.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code>
      </example>
    </member>
    <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute" /> class.
            </summary>
      <param name="customGenerator">A custom identifier 
            generator (that implements <see cref="T:NHibernate.Id.IIdentifierGenerator" />).</param>
    </member>
    <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(Castle.ActiveRecord.PrimaryKeyType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute" /> class.
            </summary>
      <param name="generator">The generator.</param>
    </member>
    <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(Castle.ActiveRecord.PrimaryKeyType,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute" /> class.
            </summary>
      <param name="generator">The generator.</param>
      <param name="column">The PK column.</param>
    </member>
    <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute" /> class.
            </summary>
      <param name="column">The PK column.</param>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Generator">
      <summary>
            Gets or sets the generator.
            </summary>
      <value>The generator.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.UnsavedValue">
      <summary>
            Gets or sets the unsaved value.
            </summary>
      <value>The unsaved value.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.SequenceName">
      <summary>
            Gets or sets the name of the sequence.
            </summary>
      <value>The name of the sequence.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.ColumnType">
      <summary>
            Gets or sets the type of the column.
            </summary>
      <value>The type of the column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Length">
      <summary>
            Gets or sets the length of values in the column
            </summary>
      <value>The length.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.CustomGenerator">
      <summary>
            Gets or sets the custom generator. 
            The generator must implement <see cref="T:NHibernate.Id.IIdentifierGenerator" /></summary>
      <value>The custom generator type.</value>
    </member>
    <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Params">
      <summary>
            Comma separated value of parameters to the generator
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.PropertyAccess">
      <summary>
            Define the various access strategies NHibernate will use to set/get the value
            for this property.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.Property">
      <summary>
            Use the property get/set methods to get and set the value of this property
            </summary>
      <example>
        <code>
            [Property(Access=PropertyAccess.Property)]
            public string UserName { get {... } set { ... } }
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.Field">
      <summary>
            Use the field to get/set the value. (Only valid when specify on a field).
            </summary>
      <example>
        <code>
            [Property(Access=PropertyAccess.Field)]
            public string UserName; // notice this is a field, not property.
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.FieldCamelcase">
      <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in camel case.
            </summary>
      <example>
        <code>
            string userName;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldCamelCase)]
            public string UserName { get {... } set { ... } }
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.FieldCamelcaseUnderscore">
      <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in camel case and with an initial underscore
            </summary>
      <example>
        <code>
            string _userName;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldCamelcaseUnderscore)]
            public string UserName { get {... } set { ... } }
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.FieldPascalcaseMUnderscore">
      <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in pascal case and with an initial m and then underscore.
            m_Name for the property Name.
            </summary>
      <example>
        <code>
            string m_UserName;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldPascalcaseMUnderscore)]
            public string UserName { get {... } set { ... } }
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.FieldLowercaseUnderscore">
      <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in all lower case and with inital underscore
            </summary>
      <example>
        <code>
            string _username;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldLowercaseUnderscore)]
            public string UserName { get {... } set { ... } }
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterCamelcase">
      <summary>
            Use the property' getter to get the value, and use the field with the same name and in camel case
            in order to set it.
            </summary>
      <example>
        <code>
            string _userName;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterCamelcase)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterCamelcaseUnderscore">
      <summary>
            Use the property' getter to get the value, and use the field with the same name and in camel case
            with initial "_" in order to set it.
            </summary>
      <example>
        <code>
            string _userName;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterCamelcaseUnderscore)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterPascalcaseMUndersc">
      <summary>
            Use the property' getter to get the value, and use the field with the same name and in pascal case
            with initial "m_" in order to set it.
            </summary>
      <example>
        <code>
            string m_UserName;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterPascalcaseMUndersc)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterLowercaseUnderscore">
      <summary>
            Use the property' getter to get the value, and use the field with the same name and in lower case
            with initial "_" in order to set it.
            </summary>
      <example>
        <code>
            string _username;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterLowercaseUnderscore)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterLowercase">
      <summary>
            Use the property' getter to get the value, and use the field with the same name and in lower case
            in order to set it.
            </summary>
      <example>
        <code>
            string username;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterLowercase)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
      </example>
    </member>
    <member name="T:Castle.ActiveRecord.PropertyAccessHelper">
      <summary>
            Utility class to help convert between <see cref="T:Castle.ActiveRecord.PropertyAccess" /> values and
            NHiberante's access strategies.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.PropertyAccessHelper.ToString(Castle.ActiveRecord.PropertyAccess)">
      <summary>
            Convert <param name="access" /> to its NHibernate string 
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.RawXmlMappingAttribute">
      <summary>
            Abstract base class for custom attributes that can generate XML and return it directly.
            This allows to customize the generate the XML passed to NHibernate in a flexible way.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.RawXmlMappingAttribute.GetMappings">
      <summary>
            Get the mapping xml to add to NHibernate's configuration.
            Note that we allow to return more than a single mapping, each string is 
            treated as a seperated document.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.RelationType">
      <summary>
            Define the relation type for a relation.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.RelationType.Guess">
      <summary>
            Let Active Record guess what is the type of the relation.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.RelationType.Bag">
      <summary>
            An bag of items (allow duplicates)
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.RelationType.Set">
      <summary>
            A set of unique items
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.RelationType.IdBag">
      <summary>
            A bag of items with id
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.RelationType.Map">
      <summary>
            Map of key/value pairs (IDictionary)
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.RelationType.List">
      <summary>
            A list of items - position in the list has meaning
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.TimestampAttribute">
      <summary>
            Specify that this property is used for timestamping this entity
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.TimestampAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TimestampAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.TimestampAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TimestampAttribute" /> class.
            </summary>
      <param name="column">The column name</param>
    </member>
    <member name="P:Castle.ActiveRecord.TimestampAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="T:Castle.ActiveRecord.VersionAttribute">
      <summary>
            This attribute is used to specify that a property is the versioning property of the class
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.VersionAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.VersionAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.VersionAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.VersionAttribute" /> class.
            </summary>
      <param name="column">The column.</param>
    </member>
    <member name="P:Castle.ActiveRecord.VersionAttribute.Column">
      <summary>
            Gets or sets the column name
            </summary>
      <value>The column.</value>
    </member>
    <member name="P:Castle.ActiveRecord.VersionAttribute.Type">
      <summary>
            Gets or sets the type of the column (should be an integer of some type)
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Castle.ActiveRecord.VersionAttribute.UnsavedValue">
      <summary>
            Gets or sets the unsaved value for this column
            </summary>
      <value>The unsaved value.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.IConfigurationSource">
      <summary>
            Abstracts the source of configuration for the framework.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.IConfigurationSource.GetConfiguration(System.Type)">
      <summary>
            Implementors should return an <see cref="T:Castle.Core.Configuration.IConfiguration" /> 
            instance
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.ThreadScopeInfoImplementation">
      <summary>
            Implementors should return the type that implements
            the interface <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /></summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.SessionFactoryHolderImplementation">
      <summary>
            Implementors should return the type that implements 
            the interface <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" /></summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.NamingStrategyImplementation">
      <summary>
            Implementors should return the type that implements
            the interface NHibernate.Cfg.INamingStrategy
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.Debug">
      <summary>
            Gets a value indicating whether this <see cref="T:Castle.ActiveRecord.Framework.IConfigurationSource" /> produce debug information
            </summary>
      <value>
        <c>true</c> if debug; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.IsLazyByDefault">
      <summary>
            Gets a value indicating whether the entities should be lazy by default.
            </summary>
      <value>
        <c>true</c> if entities should be lazy by default; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.PluralizeTableNames">
      <summary>
            Gets a value indicating whether table names are assumed plural by default. 
            </summary>
      <value>
        <c>true</c> if table names should be pluralized by default; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource">
      <summary>
            Usefull for test cases.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.GetConfiguration(System.Type)">
      <summary>
            Return an <see cref="T:Castle.Core.Configuration.IConfiguration" /> for the specified type.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Add(System.Type,System.Collections.IDictionary)">
      <summary>
            Adds the specified type with the properties
            </summary>
      <param name="type">The type.</param>
      <param name="properties">The properties.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Add(System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds the specified type with configuration
            </summary>
      <param name="type">The type.</param>
      <param name="config">The config.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetUpThreadInfoType(System.Boolean,System.String)">
      <summary>
            Sets the type of the thread info.
            </summary>
      <param name="isWeb">if we run in a web context or not</param>
      <param name="customType">Type of the custom implementation</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetUpSessionFactoryHolderType(System.String)">
      <summary>
            Sets the type of the session factory holder.
            </summary>
      <param name="customType">Custom implementation</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetUpNamingStrategyType(System.String)">
      <summary>
            Sets the type of the naming strategy.
            </summary>
      <param name="customType">Custom implementation type name</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetDebugFlag(System.Boolean)">
      <summary>
            Sets the debug flag.
            </summary>
      <param name="isDebug">if set to <c>true</c> Active Record will produce debug information.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetIsLazyByDefault(System.Boolean)">
      <summary>
            Set whatever entities are lazy by default or not.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetPluralizeTableNames(System.Boolean)">
      <summary>
            Sets the pluralizeTableNames flag.
            </summary>
      <param name="pluralize">if set to <c>true</c> Active Record will pluralize inferred table names.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.ThreadScopeInfoImplementation">
      <summary>
            Return a type that implements
            the interface <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /></summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SessionFactoryHolderImplementation">
      <summary>
            Return a type that implements
            the interface <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" /></summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.NamingStrategyImplementation">
      <summary>
            Return a type that implements
            the interface NHibernate.Cfg.INamingStrategy
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Debug">
      <summary>
            Gets a value indicating whether this <see cref="T:Castle.ActiveRecord.Framework.IConfigurationSource" /> produce debug information
            </summary>
      <value>
        <c>true</c> if debug; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.IsLazyByDefault">
      <summary>
            Gets a value indicating whether the entities should be lazy by default.
            </summary>
      <value>
        <c>true</c> if entities should be lazy by default; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.PluralizeTableNames">
      <summary>
            Gets a value indicating whether table names are assumed plural by default. 
            </summary>
      <value>
        <c>true</c> if table names should be pluralized by default; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource">
      <summary>
            Source of configuration based on Xml 
            source like files, streams or readers.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource" /> class.
            </summary>
      <param name="xmlFileName">Name of the XML file.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor(System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource" /> class.
            </summary>
      <param name="stream">The stream.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor(System.IO.TextReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource" /> class.
            </summary>
      <param name="reader">The reader.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.PopulateSource(System.Xml.XmlNode)">
      <summary>
            Populate this instance with values from the given XML node
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.BuildProperties(System.Xml.XmlNode)">
      <summary>
            Builds the configuration properties.
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler">
      <summary>
            Reads the configuration from a entry 'activerecord'
            in the xml associated with the AppDomain
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler.Create(System.Object,System.Object,System.Xml.XmlNode)">
      <summary>
            Creates a configuration section handler.
            </summary>
      <param name="parent">
      </param>
      <param name="configContext">Configuration context object.</param>
      <param name="section">
      </param>
      <returns>The created section handler object.</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler.Instance">
      <summary>
            Gets the sole instance.
            </summary>
      <value>The instance.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.IVisitable">
      <summary>
            For implementing the Visitor pattern.
            All the nodes in the model implements this interface
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitable.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel">
      <summary>
            This model of a full Active Record persistent class.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.type2Model">
      <summary>
            The mapping between a type and a model
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.isDebug">
      <summary>
            Whatever Active Record will generate debug information or not
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.isLazyByDefault">
      <summary>
            Whatever types that does not explicitly state that they are lazy should be lazy.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.pluralizeTableNames">
      <summary>
            Whether the default inferred table name is plural
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Used internally register an association between a type and its model
            </summary>
      <param name="arType">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetModel(System.Type)">
      <summary>
            Gets the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /> for a given ActiveRecord class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetModels">
      <summary>
            Gets an array containing the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /> for every registered ActiveRecord class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetNonProxy(System.Type)">
      <summary>
            Get the base type is the object is lazy
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Parent">
      <summary>
            Gets or sets the parent model
            </summary>
      <value>The parent.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Type">
      <summary>
            Gets the type for this model
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsJoinedSubClassBase">
      <summary>
            Gets or sets a value indicating whether this instance is joined sub class base.
            </summary>
      <value>
        <c>true</c> if this instance is joined sub class base; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsDiscriminatorBase">
      <summary>
            Gets or sets a value indicating whether this instance is discriminator base.
            </summary>
      <value>
        <c>true</c> if this instance is discriminator base; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsDiscriminatorSubClass">
      <summary>
            Gets or sets a value indicating whether this instance is discriminator sub class.
            </summary>
      <value>
        <c>true</c> if this instance is discriminator sub class; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsJoinedSubClass">
      <summary>
            Gets or sets a value indicating whether this instance is joined sub class.
            </summary>
      <value>
        <c>true</c> if this instance is joined sub class; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsNestedType">
      <summary>
            Gets or sets a value indicating whether this instance is nested type.
            </summary>
      <value>
        <c>true</c> if this instance is nested type; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsNestedCompositeType">
      <summary>
            Gets or sets a value indicating whether this instance is nested type.
            </summary>
      <value>
        <c>true</c> if this instance is nested type; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.ActiveRecordAtt">
      <summary>
            Gets or sets the active record attribute
            </summary>
      <value>The active record att.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Key">
      <summary>
            Used only by joined subclasses
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Timestamp">
      <summary>
            Gets or sets the timestamp model
            </summary>
      <value>The timestamp.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Version">
      <summary>
            Gets or sets the version model
            </summary>
      <value>The version.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Imports">
      <summary>
            Gets all the imports
            </summary>
      <value>The imports.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Properties">
      <summary>
            Gets all the properties
            </summary>
      <value>The properties.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Fields">
      <summary>
            Gets all the fields
            </summary>
      <value>The fields.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.ComponentParent">
      <summary>
            If the object is a component, will return the objects declared parent property.
            There should only be one, but implemented as a list
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasManyToAny">
      <summary>
            Gets the list of [has many to any] models
            </summary>
      <value>The has many to any.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Anys">
      <summary>
            Gets the list of [any] model
            </summary>
      <value>The anys.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Classes">
      <summary>
            Gets the list of the derived classes
            </summary>
      <value>The classes.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.JoinedClasses">
      <summary>
            Gets the list of derived joined classes.
            </summary>
      <value>The joined classes.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Components">
      <summary>
            Gets the list of components.
            </summary>
      <value>The components.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.BelongsTo">
      <summary>
            Gets the list of [belongs to] models
            </summary>
      <value>The belongs to.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasMany">
      <summary>
            Gets the list of [has many] models
            </summary>
      <value>The has many.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasAndBelongsToMany">
      <summary>
            Gets the list of [has and belongs to many] models
            </summary>
      <value>The has and belongs to many.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.OneToOnes">
      <summary>
            Gets the list of [one to one] models
            </summary>
      <value>The one to ones.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.CollectionIDs">
      <summary>
            Gets the list of [collection id] models
            </summary>
      <value>The collection I ds.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.PrimaryKey">
      <summary>
            For unique Primary keys
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.CompositeKey">
      <summary>
            For Composite Primary keys
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Hilos">
      <summary>
            Gets the list of [hilo] models
            </summary>
      <value>The hilos.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.NotMappedProperties">
      <summary>
            Gets the list of  properties not mapped .
            </summary>
      <value>The not mapped properties.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Validators">
      <summary>
            Gets the validators.
            </summary>
      <value>The validators.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.UseAutoImport">
      <summary>
            Gets a value indicating whether to use auto import
            </summary>
      <value>
        <c>true</c> if should use auto import; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.CompositeUserType">
      <summary>
            Gets the composite user types properties.
            </summary>
      <value>The type of the composite user.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.AnyModel">
      <summary>
            Model for [Any] association, a polymorphic assoication without common base class
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AnyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.AnyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.AnyModel" /> class.
            </summary>
      <param name="prop">The prop.</param>
      <param name="anyAtt">Any att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AnyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.AnyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.AnyModel.AnyAtt">
      <summary>
            Gets the [Any] attribute
            </summary>
      <value>Any att.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.AnyModel.MetaValues">
      <summary>
            Gets or sets the meta values.
            </summary>
      <value>The meta values.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.BelongsToModel">
      <summary>
            Model for BelongTo - A many to one assoication between persistent entities.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.BelongsToModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.BelongsToAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.BelongsToModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="belongsToAtt">The belongs to att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.BelongsToModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.BelongsToModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.BelongsToModel.BelongsToAtt">
      <summary>
            Gets the belongs to attribute
            </summary>
      <value>The belongs to att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.CollectionIDModel">
      <summary>
            This is used in IdBag scenario to specify to collection id.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.CollectionIDAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.CollectionIDModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="collAtt">The coll att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.CollectionIDAtt">
      <summary>
            Gets the collection ID att.
            </summary>
      <value>The collection ID att.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.Hilo">
      <summary>
            Gets or sets the hilo.
            </summary>
      <value>The hilo.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel">
      <summary>
            Model for representing a composite key
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.CompositeKeyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="pkAtt">The pk att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.CompositeKeyAtt">
      <summary>
            Gets the composite key att.
            </summary>
      <value>The composite key att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel">
      <summary>
            Model for representing a Composite User type map.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.CompositeUserTypeAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel" /> class.
            </summary>
      <param name="prop">The property marked with the attribute.</param>
      <param name="attribute">The metadata attribute.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.Property">
      <summary>
            Gets the property marked with the attribute.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.Attribute">
      <summary>
            Gets the attribute instance.
            </summary>
      <value>The attribute.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.DependentObjectModel">
      <summary>
             This model is used to represent a dependent object value type (&lt;composite-element/&gt; - in NHibernate talk).
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasManyAttribute,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
             Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.DependentObjectModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="hasManyAtt">The nested att.</param>
      <param name="dependentObjectModel">The nested model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.Model">
      <summary>
            Gets the model.
            </summary>
      <value>The model.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.HasManyAtt">
      <summary>
            Gets the has many attribute
            </summary>
      <value>The has many att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.FieldModel">
      <summary>
            Model for a persitent property that uses a field to get/set the values.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.FieldModel.#ctor(System.Reflection.FieldInfo,Castle.ActiveRecord.FieldAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.FieldModel" /> class.
            </summary>
      <param name="field">The field.</param>
      <param name="att">The att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.FieldModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.FieldModel.Field">
      <summary>
            Gets the field.
            </summary>
      <value>The field.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.FieldModel.FieldAtt">
      <summary>
            Gets the field attribute
            </summary>
      <value>The field att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel">
      <summary>
            Model to HasAndBelongsToMany, which is used to model a many to many assoication.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasAndBelongsToManyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="hasManyAtt">The has many att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.HasManyAtt">
      <summary>
            Gets the has many attribute
            </summary>
      <value>The has many att.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.CollectionID">
      <summary>
            Gets or sets the collection ID.
            </summary>
      <value>The collection ID.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyModel">
      <summary>
            Model to represent a HasMany ( one to many ) association
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasManyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="hasManyAtt">The has many att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyModel.HasManyAtt">
      <summary>
            Gets the has many attribute
            </summary>
      <value>The has many att.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyModel.DependentObjectModel">
      <summary>
            Gets/Sets the the dependent object model
            </summary>
      <value>The dependent object model.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel">
      <summary>
            This model represent a &lt;many-to-any/&gt; polymorphic association
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config">
      <summary>
            I need this class to pass special configuration for the many-to-any
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config.#ctor(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config" /> class.
            </summary>
      <param name="parent">The parent.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config.Parent">
      <summary>
            Gets or sets the parent model
            </summary>
      <value>The parent.</value>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasManyToAnyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel" /> class.
            </summary>
      <param name="prop">The prop.</param>
      <param name="hasManyToAnyAtt">The has many to any att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.HasManyToAnyAtt">
      <summary>
            Gets the has many to any attribute
            </summary>
      <value>The has many to any att.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Configuration">
      <summary>
            Gets the configuration.
            </summary>
      <value>The configuration.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.MetaValues">
      <summary>
            Gets or sets the meta values.
            </summary>
      <value>The meta values.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.HiloModel">
      <summary>
            Model for HiLo algorithm used to generate primary key values
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HiloModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HiloAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HiloModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="hiloAtt">The hilo att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.HiloModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HiloModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.HiloModel.HiloAtt">
      <summary>
            Gets the hilo attribute
            </summary>
      <value>The hilo att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.ImportModel">
      <summary>
            Model for importing classes so HQL queries can use them more easily.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ImportModel.#ctor(Castle.ActiveRecord.ImportAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.ImportModel" /> class.
            </summary>
      <param name="att">The att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ImportModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ImportModel.ImportAtt">
      <summary>
            Gets the import attribute
            </summary>
      <value>The import att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.KeyModel">
      <summary>
            Model for a joined key property in a joined subclass
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.KeyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.JoinedKeyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.KeyModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="att">The att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.KeyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.KeyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.KeyModel.JoinedKeyAtt">
      <summary>
            Gets the joined key attribute
            </summary>
      <value>The joined key att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.NestedModel">
      <summary>
            This model is used to represent a nested value type (&lt;component/&gt; - in NHibernate talk).
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.NestedModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.NestedAttribute,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.NestedModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="nestedAtt">The nested att.</param>
      <param name="nestedModel">The nested model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.NestedModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.NestedModel.Model">
      <summary>
            Gets the model.
            </summary>
      <value>The model.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.NestedModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.NestedModel.NestedAtt">
      <summary>
            Gets the nested attribute
            </summary>
      <value>The nested att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel">
      <summary>
            This model is used to represent a nested value type's parent (&lt;parent /&gt; - in NHibernate talk).
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.NestedParentReferenceAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="nestedParentAtt">The parent att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.NestedParentAtt">
      <summary>
            Gets the nested attribute
            </summary>
      <value>The nested att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.OneToOneModel">
      <summary>
            Model One To One assoication
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.OneToOneModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.OneToOneAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.OneToOneModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="att">The att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.OneToOneModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.OneToOneModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.OneToOneModel.OneToOneAtt">
      <summary>
            Gets the one to one attribute
            </summary>
      <value>The one to one att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel">
      <summary>
            Model for a Primary Key
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.PrimaryKeyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel" /> class.
            </summary>
      <param name="propInfo">The prop info.</param>
      <param name="pkAtt">The pk att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.PrimaryKeyAtt">
      <summary>
            Gets the primary key attribute
            </summary>
      <value>The primary key att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.PropertyModel">
      <summary>
            Model for a simple persistent property
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.PropertyModel.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.PropertyModel" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.PropertyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.PropertyAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.PropertyModel" /> class.
            </summary>
      <param name="prop">The prop.</param>
      <param name="att">The att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.PropertyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.PropertyModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.PropertyModel.PropertyAtt">
      <summary>
            Gets the property attribute
            </summary>
      <value>The property att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.TimestampModel">
      <summary>
            Model for [Timestamp] properties
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.TimestampModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.TimestampAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.TimestampModel" /> class.
            </summary>
      <param name="prop">The prop.</param>
      <param name="att">The att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.TimestampModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.TimestampModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.TimestampModel.TimestampAtt">
      <summary>
            Gets the timestamp attribute
            </summary>
      <value>The timestamp att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.VersionModel">
      <summary>
            Model for version property on an entity
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.VersionModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.VersionAttribute)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.VersionModel" /> class.
            </summary>
      <param name="prop">The prop.</param>
      <param name="att">The att.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.VersionModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
      <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
      <param name="visitor">The visitor.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.VersionModel.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.VersionModel.VersionAtt">
      <summary>
            Gets the version attribute
            </summary>
      <value>The version att.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.IVisitor">
      <summary>
            For implementign the visitor pattern.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Visits the top level of the model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
      <summary>
            Visits the primary key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
      <summary>
            Visits the composite primary key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
      <summary>
            Visits the has many to any association
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
      <summary>
            Visits any.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
      <summary>
            Visits the property.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
      <summary>
            Visits the field.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitNestedParentReference(Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel)">
      <summary>
            Visits the component parent reference
            </summary>
      <param name="referenceModel">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
      <summary>
            Visits the version.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
      <summary>
            Visits the timestamp.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
      <summary>
            Visits the key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
      <summary>
            Visits the belongs to association
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
      <summary>
            Visits the has many association
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
      <summary>
            Visits the one to one association
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
      <summary>
            Visits the has and belongs to many association
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
      <summary>
            Visits the hilo strategy
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
      <summary>
            Visits the nested (component) model
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
      <summary>
            Visits the collection ID.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasManyToAnyConfig(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config)">
      <summary>
            Visits the has many to any configuration
            </summary>
      <param name="hasManyToAnyConfigModel">The has many to any config model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitImport(Castle.ActiveRecord.Framework.Internal.ImportModel)">
      <summary>
            Visits the import statement
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitDependentObject(Castle.ActiveRecord.Framework.Internal.DependentObjectModel)">
      <summary>
            Visits the dependent object model
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitCompositeUserType(Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel)">
      <summary>
            Visits the custom composite user type.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor">
      <summary>
            Base class for visitors that needs to traverse the entire Active Record Model
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNode(Castle.ActiveRecord.Framework.Internal.IVisitable)">
      <summary>
            Visits the node.
            </summary>
      <param name="visitable">The visitable.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNodes(System.Collections.IEnumerable)">
      <summary>
            Visits the nodes.
            </summary>
      <param name="nodes">The nodes.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Visits the model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
      <summary>
            Visits the primary key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
      <summary>
            Visits the composite primary key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
      <summary>
            Visits the has many to any.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
      <summary>
            Visits the property.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
      <summary>
            Visits the field.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNestedParentReference(Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel)">
      <summary>
            Visits the component parent
            </summary>
      <param name="referenceModel">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
      <summary>
            Visits any.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
      <summary>
            Visits the version.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
      <summary>
            Visits the timestamp.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
      <summary>
            Visits the key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
      <summary>
            Visits the belongs to.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
      <summary>
            Visits the has many.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
      <summary>
            Visits the one to one.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
      <summary>
            Visits the has and belongs to many.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
      <summary>
            Visits the hilo.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
      <summary>
            Visits the nested.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
      <summary>
            Visits the collection ID.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasManyToAnyConfig(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config)">
      <summary>
            Visits the has many to any config.
            </summary>
      <param name="hasManyToAnyConfigModel">The has many to any config model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitImport(Castle.ActiveRecord.Framework.Internal.ImportModel)">
      <summary>
            Visits the import.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitDependentObject(Castle.ActiveRecord.Framework.Internal.DependentObjectModel)">
      <summary>
            Visits the Dependent Object 
            </summary>
      <param name="model">The model</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitCompositeUserType(Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel)">
      <summary>
            Visits the custom composite user type.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.GuessType(System.Type,System.Type)">
      <summary>
            Guesses the type of the other end.
            </summary>
      <param name="type">The type.</param>
      <param name="propertyType">Type of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor">
      <summary>
            Connects <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /> with their parents 
            <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /></summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.#ctor(Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor" /> class.
            </summary>
      <param name="arCollection">The ar collection.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Visits the model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
      <summary>
            Visits the nested.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
      <summary>
            Visits the collection ID.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
      <summary>
            Visits the hilo model
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor">
      <summary>
            Traverse the tree checking the semantics of the relation and
            association. The goal is to raise clear exceptions with tips of how 
            to fix any error.
            It also tries to infer as much information from the class / attribute model as possible so it can
            complete the missing infomration without the user needing to specify it.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.#ctor(Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor" /> class.
            </summary>
      <param name="arCollection">The ar collection.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Visits the model.
            </summary>
      <remarks>
            Check that the model:
             - Define only a discriminator or a join subclass, not both
             - Doesn't specify version/timestamp property on a joined subclass / discriminator subclass
             - Validate that the custom entity persister implements IEntityPersister
             - Validate the joined subclasses has a [JoinedKey] to map back to the parent table
             - Validate that the class has a PK
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
      <summary>
            Visits the primary key.
            </summary>
      <remarks>
            Infer column name and the reverse property if using [OneToOne]
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
      <summary>
            Visits the composite primary key.
            </summary>
      <remarks>
            Validate that the composite key type is implementing GetHashCode() and Equals(), is mark serializable.
            Validate that the compose key is compose of two or more columns
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
      <summary>
            Visits the property.
            </summary>
      <remarks>
            Infer column name and whatever this propery can be null or not
            Also catch common mistake of try to use [Property] on an entity, instead of [BelongsTo]
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
      <summary>
            Visits the field.
            </summary>
      <remarks>
            Infer column name and nullablity
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
      <summary>
            Visits the key.
            </summary>
      <remarks>
            Infer column name
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
      <summary>
            Visits the version.
            </summary>
      <remarks>
            Infer column name
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
      <summary>
            Visits the timestamp.
            </summary>
      <remarks>
            Infer column name
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
      <summary>
            Visits the belongs to.
            </summary>
      <remarks>
            Infer column name and type
            Verify that the property is virtual if the class was marked lazy.
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
      <summary>
            Visit the has many to any
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
      <summary>
            Visits any.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
      <summary>
            Visits the has many.
            </summary>
      <remarks>
            Guess the type of the relation, if not specified explicitly
            Verify that the assoication is valid on [HasMany]
            Validate that required information is specified
            Infer the other side of the assoication and grab require data from it
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
      <summary>
            Visits the has and belongs to many.
            </summary>
      <remarks>
            Verify that a link table was specified
            Verify that a key was specified and that it is valid 
            Verify that required information was specified
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
      <summary>
            Visits the one to one.
            </summary>
      <remarks>
            Infer the type on the other side
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
      <summary>
            Visits the nested model
            </summary>
      <remarks>
            Infer the column name and applies and column prefixes specified
            </remarks>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.GetIndexTypeFromDictionary(System.Type)">
      <summary>
            Gets the index type of a mapped dictionary.
            </summary>
      <param name="propertyType">Type of the property.</param>
      <returns>The index type of a map element</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.GetMapTypeFromDictionary(System.Type)">
      <summary>
            Gets the index type of a mapped dictionary.
            </summary>
      <param name="propertyType">Type of the property.</param>
      <returns>The index type of a map element</returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor">
      <summary>
            Traverse the tree emitting proper xml configuration
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.Reset">
      <summary>
            Resets this instance.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.CreateXml(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Creates the XML.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Visits the model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
      <summary>
            Visits the primary key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
      <summary>
            Visits the composite primary key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitImport(Castle.ActiveRecord.Framework.Internal.ImportModel)">
      <summary>
            Visits the import.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
      <summary>
            Visits the property.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
      <summary>
            Visits the field.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitNestedParentReference(Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel)">
      <summary>
            Visits the parent
            </summary>
      <param name="referenceModel">The reference model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
      <summary>
            Visits any.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
      <summary>
            Visits the has many to any.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasManyToAnyConfig(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config)">
      <summary>
            Visits the has many to any config.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
      <summary>
            Visits the version.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
      <summary>
            Visits the timestamp.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
      <summary>
            Visits the key.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
      <summary>
            Visits the one to one.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
      <summary>
            Visits the belongs to.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
      <summary>
            Visits the has many.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
      <summary>
            Visits the has and belongs to many.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
      <summary>
            Visits the nested.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitDependentObject(Castle.ActiveRecord.Framework.Internal.DependentObjectModel)">
      <summary>
            Visits the dependent object.
            </summary>
      <param name="model">The model</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
      <summary>
            Visits the collection ID.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
      <summary>
            Visits the hilo.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitCompositeUserType(Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel)">
      <summary>
            Visits the custom composite user type.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.MakeTypeName(System.Type)">
      <summary>
            Create a valid name from a type, without including all the version and public key
            information
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.Xml">
      <summary>
            Gets the XML.
            </summary>
      <value>The XML.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder">
      <summary>
            Bulids an <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /> from a type and does some inital validation.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.Create(System.Type)">
      <summary>
            Creates a <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /> from the specified type.
            </summary>
      <param name="type">The type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.PopulateModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel,System.Type)">
      <summary>
            Populates the model from tye type
            </summary>
      <param name="model">The model.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.GetSafeName(System.String)">
      <summary>
            Remove the generic part from the typename.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.Models">
      <summary>
            Gets the models.
            </summary>
      <value>The models.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection">
      <summary>
            Map System.Type to their ActiveRecordModel
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.Add(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Adds the specified model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.Contains(System.Type)">
      <summary>
            Determines whether the collection contains the specified type.
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if the collection contains the specified type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.Item(System.Type)">
      <summary>
            Gets the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /> with the specified type.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator">
      <summary>
            Generate xml from assembly level attributes.
            This is useful if we need to have type-less configuration, such as imports, named queries, etc.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator.#ctor">
      <summary>
            Create a new instnace
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator.Reset">
      <summary>
            Reset this generator and prepare to generate xml from new assembly.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator.CreateXmlConfigurations(System.Reflection.Assembly)">
      <summary>
            Generate XML from assembly attributes.
            If it can't find relevant attributes, returns null.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.Inflector">
      <summary>
            The Inflector class transforms words from one 
            form to another. For example, from singular to plural.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.Inflector.Pluralize(System.String)">
      <summary>
            Return the plural of a word.
            </summary>
      <param name="word">The singular form</param>
      <returns>The plural form of <paramref name="word" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.Inflector.Singularize(System.String)">
      <summary>
            Return the singular of a word.
            </summary>
      <param name="word">The plural form</param>
      <returns>The singular form of <paramref name="word" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.Inflector.Capitalize(System.String)">
      <summary>
            Capitalizes a word.
            </summary>
      <param name="word">The word to be capitalized.</param>
      <returns>
        <paramref name="word" /> capitalized.</returns>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.Modifiers.IQueryModifier">
      <summary>
            Any object which intent to change a NHibernate query must implement
            this interface.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.IQueryModifier.Apply(NHibernate.IQuery)">
      <summary>
            Applies this modifier to the query.
            </summary>
      <param name="query">The query</param>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter">
      <summary>
            Represents a query parameter.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter" /> class.
            </summary>
      <param name="position">The position.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object,NHibernate.Type.IType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter" /> class.
            </summary>
      <param name="position">The position.</param>
      <param name="value">The value.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Collections.ICollection,NHibernate.Type.IType)">
      <remarks>
            It is important to keep this constructor as is, to avoid
            confusion with the <see cref="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object,NHibernate.Type.IType)" />
            overload.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Collections.ICollection)">
      <remarks>
            It is important to keep this constructor as is, to avoid
            confusion with the <see cref="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object)" />
            overload.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Apply(NHibernate.IQuery)">
      <summary>
            Add this parameter to the <paramref name="query" />.
            </summary>
      <param name="query">The query</param>
      <remarks>
            Is there a cleaner way to do this, without reflection or complex
            hierarchies?
            </remarks>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Position">
      <summary>
            The position of the positional parameter, or <c>-1</c>
            if this is a named parameter.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Name">
      <summary>
            The name of the named parameter, or <c>null</c>
            if this is a positional parameter.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Value">
      <summary>
            The parameter value.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Type">
      <summary>
            The NHibernate type.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.Modifiers.QueryRange">
      <summary>
            Limits a query to the specified results.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryRange.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryRange" /> class.
            </summary>
      <param name="firstResult">The first result.</param>
      <param name="maxResults">The max results.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryRange.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryRange" /> class.
            </summary>
      <param name="maxResults">The max results.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryRange.Apply(NHibernate.IQuery)">
      <summary>
            Applies this modifier to the query.
            </summary>
      <param name="query">The query</param>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryRange.FirstResult">
      <summary>
            Gets the first result.
            </summary>
      <value>The first result.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryRange.MaxResults">
      <summary>
            Gets the max results.
            </summary>
      <value>The max results.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition">
      <summary>
            Represents a SQL query return definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])" /> for more information.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition" /> class.
            </summary>
      <param name="returnType">Type of the return object.</param>
      <param name="returnAlias">Gets the alias for the object</param>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition.ReturnType">
      <summary>
            Gets the type of the returned object
            </summary>
      <value>The type of the return.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition.ReturnAlias">
      <summary>
            Gets the alias for the object
            </summary>
      <value>The return alias.</value>
    </member>
    <member name="T:Castle.ActiveRecord.IActiveRecordQuery">
      <summary>
            Represents an ActiveRecord Query.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.IActiveRecordQuery.Execute(NHibernate.ISession)">
      <summary>
            Executes the specified query and return the results
            </summary>
      <param name="session">The session to execute the query in.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.IActiveRecordQuery.Enumerate(NHibernate.ISession)">
      <summary>
            Enumerates over the result of the query.
            Note: Only use if you expect most of your values to already exist in the second level cache!
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.IActiveRecordQuery.RootType">
      <summary>
            Gets the target type of this query
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordBaseQuery">
      <summary>
            Base class for all ActiveRecord queries.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ActiveRecordBaseQuery.queryModifiers">
      <summary>
            list of modifiers for the query
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ActiveRecordBaseQuery" /> class.
            </summary>
      <param name="rootType">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalExecute(NHibernate.ISession)">
      <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.List" /> method.
            </summary>
      <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession" /></param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalEnumerate(NHibernate.ISession)">
      <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.Enumerable" /> method.
            Note: Only use when you expect most of the results to be in the second level cache
            </summary>
      <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession" /></param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddQuery(NHibernate.ISession,NHibernate.IMultiQuery)">
      <summary>
            Add this query to a multiquery
            </summary>
      <param name="session">an <c>ISession</c> shared by all queries in the multiquery</param>
      <param name="multiquery">the <c>IMultiQuery</c> that will receive the newly created query</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.CreateQuery(NHibernate.ISession)">
      <summary>
            Creates the <see cref="T:NHibernate.IQuery" /> instance.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.Clone">
      <summary>
            Just a default clone implementation...
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddModifier(Castle.ActiveRecord.Queries.Modifiers.IQueryModifier)">
      <summary>
            Adds a query modifier, to be applied with <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.ApplyModifiers(NHibernate.IQuery)" />.
            </summary>
      <param name="modifier">The modifier</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.ApplyModifiers(NHibernate.IQuery)">
      <summary>
            Applies the modifiers added with <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddModifier(Castle.ActiveRecord.Queries.Modifiers.IQueryModifier)" />.
            </summary>
      <param name="query">The query in which to apply the modifiers</param>
      <remarks>
            This method is not called automatically 
            by <see cref="T:Castle.ActiveRecord.ActiveRecordBaseQuery" />, but is called from
            <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery" />.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetResultsArray(System.Type,System.Collections.IList,System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IList" /> to an
            strongly-typed array.
            </summary>
      <param name="t">The type of the new array</param>
      <param name="list">The source list</param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetResultsArray(System.Type,System.Collections.IList,System.Int32,System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IList" /> to an
            strongly-typed array.
            </summary>
      <param name="t">The type of the new array</param>
      <param name="list">The source list</param>
      <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetModifiers(Castle.ActiveRecord.ActiveRecordBaseQuery)">
      <summary>
            Gets the internal list of modifiers used by the specified query.
            NOT INTENTED FOR NORMAL USE.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordBaseQuery.RootType">
      <summary>
            Gets the target type of this query
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordBaseQuery.Log">
      <summary>
            Use the specified logger to output diagnostic messages.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.HqlBasedQuery">
      <summary>
            Base class for all HQL or SQL-based queries.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="query">The query.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="query">The query.</param>
      <param name="positionalParameters">The positional parameters.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="queryLanguage">The query language.</param>
      <param name="query">The query.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="queryLanguage">The query language.</param>
      <param name="query">The query.</param>
      <param name="positionalParameters">The positional parameters.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameter(System.String,System.Object)">
      <summary>
            Sets a parameter with the given name.
            </summary>
      <param name="parameterName">Name of the parameter.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Sets a parameter with the given name and type
            </summary>
      <param name="parameterName">Name of the parameter.</param>
      <param name="value">The value.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameterList(System.String,System.Collections.ICollection)">
      <summary>
            Sets a parameter with the given name with a list of values
            </summary>
      <param name="parameterName">Name of the parameter.</param>
      <param name="list">The list.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
      <summary>
            Sets a parameter with the given name with a list of values and type
            </summary>
      <param name="parameterName">Name of the parameter.</param>
      <param name="list">The list.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetQueryRange(System.Int32,System.Int32)">
      <summary>
            Sets the query range (paging)
            </summary>
      <param name="firstResult">The first result.</param>
      <param name="maxResults">The maximum number of results returned (page size)</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetQueryRange(System.Int32)">
      <summary>
            Sets the query range (maximum number of items returned)
            </summary>
      <param name="maxResults">The maximum number of results.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.AddSqlReturnDefinition(System.Type,System.String)">
      <summary>
            Adds a SQL query return definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])" /> for more information.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.CreateQuery(NHibernate.ISession)">
      <summary>
            Creates the <see cref="T:NHibernate.IQuery" /> instance.
            </summary>
      <param name="session">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.HqlBasedQuery.Query">
      <summary>
            The query text.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery">
      <summary>
            Criteria Query
            Note: This query can not be included in a MultiQuery.
            the problem is that NHibernate does not have a real CriteriaQuery class
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery.#ctor(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery" /> class.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="criterias">Criteria applied to the query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery.#ctor(System.Type,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery" /> class.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="detachedCriteria">Criteria applied to the query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery.InternalExecute(NHibernate.ISession)">
      <summary>
            Executes the query.
            </summary>
      <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession" /></param>
      <returns>
        <c>ArrayList</c> as an <c>object</c></returns>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery">
      <summary>
            wrapper for an IMultiQuery that executes a collection of queries.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery" /> class.
            </summary>
      <param name="RootType">the root type for all of the queries that will be included in the <c>IMultiQuery</c></param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.#ctor(System.Type,Castle.ActiveRecord.ActiveRecordBaseQuery[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery" /> class.
            </summary>
      <param name="RootType">the root type for all of the queries that will be included in the <c>IMultiQuery</c></param>
      <param name="activeRecordQueries">an array of <c>IActiveRecordQuery</c></param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.Add(Castle.ActiveRecord.ActiveRecordBaseQuery)">
      <summary>
            Add an <c>IActiveRecordQuery</c> to our <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery" /></summary>
      <param name="activeRecordQuery">
        <c>IActiveRecordQuery</c> to be added to the MultiQuery</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.Execute(NHibernate.ISession)">
      <summary>
            Executes the specified query and return the results
            </summary>
      <param name="session">The session to execute the query in.</param>
      <returns>an array of results, one for each query added</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.Enumerate(NHibernate.ISession)">
      <summary>
            (Not Implemented!)
            Enumerates over the result of the query.
            Note: Only use if you expect most of your values to already exist in the second level cache!
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.RootType">
      <summary>
            Gets the target type of this query
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.CountQuery">
      <summary>
            Query the database for a count (using COUNT(*) ) of all the entites of the specified type.
            Optionally using a where clause;
            Note: If Criteria are used, this query can not be included in a MultiQuery.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery" /> class.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="filter">The filter.</param>
      <param name="parameters">The parameters.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery" /> class.
            </summary>
      <param name="targetType">The target type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery" /> class.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="criterias">Criteria applied to the query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery" /> class.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="detachedCriteria">Criteria applied to the query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.CountQuery.InternalExecute(NHibernate.ISession)">
      <summary>
            Executes the query.
            </summary>
      <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession" /></param>
      <returns>
        <c>System.Int32</c> as object</returns>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.QueryLanguage">
      <summary>
            defines the possible query langauges
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Queries.QueryLanguage.Hql">
      <summary>
            Hibernate Query Language
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Queries.QueryLanguage.Sql">
      <summary>
            Structured Query Language
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.IActiveRecordQuery`1">
      <summary>
            Represents an ActiveRecord Query.
            </summary>
      <typeparam name="T">The resulting object type</typeparam>
    </member>
    <member name="M:Castle.ActiveRecord.IActiveRecordQuery`1.Execute(NHibernate.ISession)">
      <summary>
            Executes the query using specified session.
            </summary>
      <param name="session">The session.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.ProjectionQuery`2">
      <summary>
            Performs a projected selection from an entity, lifting only the required fields.
            Similar to SELECT Id,Name FROM MyTable instead of selecting everything.
            It is possible to combine this with grouping. 
            </summary>
      <typeparam name="ARType">The active record entity type</typeparam>
      <typeparam name="TResultItem">The result value to use: object[] means returning as is</typeparam>
            /// <example><code><![CDATA[
            ProjectionQuery<Post, PostTitleAndId> proj = new ProjectionQuery<Post, PostTitleAndId>(Projections.Property("Title"), Projections.Property("Id"));
            ICollection<PostTitleAndId> posts = proj.Execute();
            foreach(PostTitleAndId titleAndId in posts)
            {
            	//push to site...
            }
            ]]></code></example></member>
    <member name="T:Castle.ActiveRecord.Queries.ProjectionQuery`2.TypedResultTransformer`1">
      <summary>
            This is used to convert the resulting tuples into strongly typed objects.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.TypedResultTransformer`1.TransformTuple(System.Object[],System.String[])">
      <summary>
            Convert the tuples into a strongly typed object
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given
            </summary>
      <param name="projections">The projections to use in the query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[],NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
      <param name="detachedCriteria">Criteria to select by</param>
      <param name="orders">The order by which to get the result</param>
      <param name="projections">The projections</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order,NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
      <param name="detachedCriteria">Criteria to select by</param>
      <param name="order">The order by which to get the result</param>
      <param name="projections">The projections</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Expression.Order,NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The results will be loaded according to the order specified
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.SetRange(System.Int32,System.Int32)">
      <summary>
            Sets the query range.
            </summary>
      <param name="first">The first row to return.</param>
      <param name="max">The max number of rows to return.</param>
      <returns>The instance</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.Enumerate(NHibernate.ISession)">
      <summary>
            Enumerates over the result of the query.
            Note: Only use if you expect most of your values to already exist in the second level cache!
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.Execute">
      <summary>
            Executes the specified query and return the results
            </summary>
      <returns>the result of the query</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.ProjectionQuery`2.RootType">
      <summary>
            Gets the target type of this query
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.ProjectionQuery`1">
      <summary>
            Default implemenation of ProjectionQuery that returns an Untyped object array tuples
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given
            </summary>
      <param name="projections">The projections to use in the query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[],NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
      <param name="detachedCriteria">Criteria to select by</param>
      <param name="orders">The order by which to get the result</param>
      <param name="projections">The projections</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order,NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
      <param name="detachedCriteria">Criteria to select by</param>
      <param name="order">The order by which to get the result</param>
      <param name="projections">The projections</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Expression.Order,NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The results will be loaded according to the order specified
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.ProjectionList)">
      <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2" /> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2">
      <summary>
            Perform a scalar projection ( aggeregate ) type of query:
            avg, max, count(*), etc.
            </summary>
      <typeparam name="ARType">The type of the entity we are querying</typeparam>
      <typeparam name="TResult">The type of the scalar from this query</typeparam>
      <example>
        <code>
            ScalarProjectionQuery&lt;Blog, int&gt; proj = new ScalarProjectionQuery&lt;Blog, int&gt;(Projections.RowCount());
            int rowCount = proj.Execute();
            </code>
      </example>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.#ctor(NHibernate.Expression.IProjection,NHibernate.Expression.ICriterion[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2" /> class.
            </summary>
      <param name="projection">The projection.</param>
      <param name="criterions">The criterions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.#ctor(NHibernate.Expression.IProjection,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2" /> class.
            </summary>
      <param name="projection">The projection.</param>
      <param name="criteria">The detached criteria.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.Enumerate(NHibernate.ISession)">
      <summary>
            Enumerates over the result of the query.
            Always returns a single result
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.Execute(NHibernate.ISession)">
      <summary>
            Executes the specified query and return the results
            </summary>
      <param name="session">The session to execute the query in.</param>
      <returns>the result of the query</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.Execute">
      <summary>
            Executes the specified query and return the results
            </summary>
      <returns>the result of the query</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.RootType">
      <summary>
            Gets the target type of this query
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.ScalarQuery">
      <summary>
            Query that return a single result
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="query">The query.</param>
      <param name="positionalParameters">The positional parameters.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="query">The query.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="queryLanguage">The query language.</param>
      <param name="query">The query.</param>
      <param name="positionalParameters">The positional parameters.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="queryLanguage">The query language.</param>
      <param name="query">The query.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.InternalExecute(NHibernate.ISession)">
      <summary>
            Executes the query and returns its scalar result.
            </summary>
      <param name="session">The NHibernate's <see cref="T:NHibernate.ISession" /></param>
      <returns>The query's scalar result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.InternalEnumerate(NHibernate.ISession)">
      <summary>
            Creates a single-position object array containing 
            the query's scalar result.
            </summary>
      <param name="session">The NHibernate's <see cref="T:NHibernate.ISession" /></param>
      <returns>An <c>object[1]</c> containing the query's scalar result.</returns>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.ScalarQuery`1">
      <summary>
            Represents a query that can result in a value
            of the type <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The resulting object type</typeparam>
      <remarks>
            If the query result is null, and <typeparamref name="T" /> is a value type,
            the default value for that type will be returned.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,System.String,System.Object[])">
      <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query" />,
            using the specified positional <paramref name="positionalParameters" /> and
            the target ActiveRecord type specified in <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="query">The query</param>
      <param name="positionalParameters">The positional positionalParameters</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,System.String)">
      <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query" /> and
            the target ActiveRecord type specified in <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="query">The query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
      <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query" />,
            using the specified positional <paramref name="positionalParameters" /> and
            the target ActiveRecord type specified in <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="queryLanguage">The language of the query</param>
      <param name="query">The query</param>
      <param name="positionalParameters">The positional positionalParameters</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String)">
      <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query" /> and
            the target ActiveRecord type specified in <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="queryLanguage">The language of the query</param>
      <param name="query">The query</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.Execute">
      <summary>
            Executes the query and gets the result.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.SimpleQuery">
      <summary>
            Simple query.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.Type,System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.InternalExecute(NHibernate.ISession)">
      <summary>
            Executes the query and converts the results into a strongly-typed
            array of <see cref="F:Castle.ActiveRecord.Queries.SimpleQuery.returnType" />.
            </summary>
      <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession" /></param>
    </member>
    <member name="T:Castle.ActiveRecord.Queries.SimpleQuery`1">
      <summary>
            Represents a query that can result in an array of 
            objects of the type <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The resulting object type</typeparam>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query" />,
            using the specified positional <paramref name="positionalParameters" />.
            The target ActiveRecord type is <typeparamref name="T" />.
            </summary>
      <param name="query">The query</param>
      <param name="positionalParameters">The positional parameters</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query" />,
            using the specified positional <paramref name="positionalParameters" />.
            The target ActiveRecord type is <typeparamref name="T" />.
            </summary>
      <param name="query">The query</param>
      <param name="queryLanguage">The query language</param>
      <param name="positionalParameters">The positional parameters</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.Type,System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query" />,
            using the specified positional <paramref name="positionalParameters" /> and
            the target ActiveRecord type specified in <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="query">The query</param>
      <param name="positionalParameters">The positional parameters</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
      <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query" />,
            using the specified positional <paramref name="positionalParameters" /> and
            the target ActiveRecord type specified in <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="queryLanguage">The query language</param>
      <param name="query">The query</param>
      <param name="positionalParameters">The positional parameters</param>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.Execute">
      <summary>
            Executes the query and gets the results.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.Enumerate">
      <summary>
            Enumerates the query results. Better suited for queries 
            which might return large results.
            <seealso cref="M:NHibernate.IQuery.Enumerable" /></summary>
      <remarks>
            It might not look obvious at first, but 
            <see cref="T:Castle.ActiveRecord.ActiveRecordMediator" /> will call our 
            <see cref="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerate(NHibernate.ISession)" />, which will call our 
            <see cref="M:Castle.ActiveRecord.Queries.SimpleQuery`1.GenericEnumerate(NHibernate.ISession)" />, which will convert
            the <c>NHibernate</c>'s <see cref="M:NHibernate.IQuery.Enumerable" /> result
            returned by <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalEnumerate(NHibernate.ISession)" />
            into a generic <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            So, all we need to do is to cast it back to <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerate(NHibernate.ISession)">
      <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.Enumerable" /> method.
            Note: Only use when you expect most of the results to be in the second level cache
            </summary>
      <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession" /></param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerateFromBase(NHibernate.ISession)">
      <summary>
            Needed to avoid <c>CS1911</c>.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalExecute(NHibernate.ISession)">
      <summary>
            Executes the query and converts the results into a strongly-typed
            array of <typeparamref name="T" />.
            </summary>
      <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession" /></param>
    </member>
    <member name="T:Castle.ActiveRecord.ISessionScope">
      <summary>
            Contract for implementation of scopes.
            </summary>
      <remarks>
            A scope can implement a logic that affects 
            AR for the scope lifetime. Session cache and
            transaction are the best examples, but you 
            can create new scopes adding new semantics.
            <para>
            The methods on this interface are mostly invoked
            by the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            implementation
            </para></remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ISessionScope.Flush">
      <summary>
            Flushes the sessions that this scope 
            is maintaining
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)">
      <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            just created one. So it registers the session created 
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)" /></summary>
      <param name="key">an object instance</param>
      <param name="session">An instance of <c>ISession</c></param>
    </member>
    <member name="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)">
      <summary>
            This method is invoked when the 
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key. 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)" /></summary>
      <param name="key">an object instance</param>
      <returns>
        <c>true</c> if the key exists within this scope instance</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ISessionScope.GetSession(System.Object)">
      <summary>
            This method should return the session instance associated with the key.
            </summary>
      <param name="key">an object instance</param>
      <returns>the session instance or null if none was found</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ISessionScope.OpenSession(NHibernate.ISessionFactory,NHibernate.IInterceptor)">
      <summary>
            If the <see cref="P:Castle.ActiveRecord.ISessionScope.WantsToCreateTheSession" /> returned
            <c>true</c> then this method is invoked to allow 
            the scope to create a properly configured session
            </summary>
      <param name="sessionFactory">From where to open the session</param>
      <param name="interceptor">the NHibernate interceptor</param>
      <returns>the newly created session</returns>
    </member>
    <member name="P:Castle.ActiveRecord.ISessionScope.FlushAction">
      <summary>
            Returns the <see cref="P:Castle.ActiveRecord.ISessionScope.FlushAction" /> defined 
            for this scope
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ISessionScope.ScopeType">
      <summary>
            Returns the <see cref="T:Castle.ActiveRecord.SessionScopeType" /> defined 
            for this scope
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ISessionScope.WantsToCreateTheSession">
      <summary>
            Implementors should return true if they
            want that their scope implementation 
            be in charge of creating the session
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractScope">
      <summary>
            Abstract <seealso cref="T:Castle.ActiveRecord.ISessionScope" /> implementation
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.Scopes.AbstractScope.key2Session">
      <summary>
            Map between a key to its session
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.#ctor(Castle.ActiveRecord.FlushAction,Castle.ActiveRecord.SessionScopeType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.AbstractScope" /> class.
            </summary>
      <param name="flushAction">The flush action.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.Flush">
      <summary>
            Flushes the sessions that this scope 
            is maintaining
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.IsKeyKnown(System.Object)">
      <summary>
            This method is invoked when the
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key.
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.RegisterSession(System.Object,NHibernate.ISession)" /></summary>
      <param name="key">an object instance</param>
      <returns>
        <c>true</c> if the key exists within this scope instance
            </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.RegisterSession(System.Object,NHibernate.ISession)">
      <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            just created one. So it registers the session created
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.IsKeyKnown(System.Object)" /></summary>
      <param name="key">an object instance</param>
      <param name="session">An instance of <c>ISession</c></param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.GetSession(System.Object)">
      <summary>
            This method should return the session instance associated with the key.
            </summary>
      <param name="key">an object instance</param>
      <returns>
            the session instance or null if none was found
            </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.OpenSession(NHibernate.ISessionFactory,NHibernate.IInterceptor)">
      <summary>
            If the <see cref="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.WantsToCreateTheSession" /> returned
            <c>true</c> then this method is invoked to allow
            the scope to create a properly configured session
            </summary>
      <param name="sessionFactory">From where to open the session</param>
      <param name="interceptor">the NHibernate interceptor</param>
      <returns>the newly created session</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.Initialize(NHibernate.ISession)">
      <summary>
            Initializes the specified session.
            </summary>
      <param name="session">The session.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.PerformDisposal(System.Collections.ICollection)">
      <summary>
            Performs the disposal.
            </summary>
      <param name="sessions">The sessions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.PerformDisposal(System.Collections.ICollection,System.Boolean,System.Boolean)">
      <summary>
            Performs the disposal.
            </summary>
      <param name="sessions">The sessions.</param>
      <param name="flush">if set to <c>true</c> [flush].</param>
      <param name="close">if set to <c>true</c> [close].</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.DiscardSessions(System.Collections.ICollection)">
      <summary>
            Discards the sessions.
            </summary>
      <param name="sessions">The sessions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.SetFlushMode(NHibernate.ISession)">
      <summary>
            Sets the flush mode.
            </summary>
      <param name="session">The session.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.GetSessions">
      <summary>
            Gets the sessions.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.RemoveSession(NHibernate.ISession)">
      <summary>
            Removes the session.
            </summary>
      <param name="session">The session.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.ScopeType">
      <summary>
            Returns the <see cref="T:Castle.ActiveRecord.SessionScopeType" /> defined 
            for this scope
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.FlushAction">
      <summary>
            Returns the <see cref="P:Castle.ActiveRecord.ISessionScope.FlushAction" /> defined 
            for this scope
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.WantsToCreateTheSession">
      <summary>
            Implementors should return true if they
            want that their scope implementation
            be in charge of creating the session
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.IThreadScopeInfo">
      <summary>
            Implementation of this interface provide a way to get the current scope.
            This is used by the rest of the Active Record framework to grab a scope (and from it a session).
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.IThreadScopeInfo.GetRegisteredScope">
      <summary>
            Gets the registered scope.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.IThreadScopeInfo.RegisterScope(Castle.ActiveRecord.ISessionScope)">
      <summary>
            Registers the scope.
            </summary>
      <param name="scope">The scope.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.IThreadScopeInfo.UnRegisterScope(Castle.ActiveRecord.ISessionScope)">
      <summary>
            Unregister the scope.
            </summary>
      <param name="scope">The scope.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IThreadScopeInfo.CurrentStack">
      <summary>
            Gets the current stack.
            </summary>
      <value>The current stack.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IThreadScopeInfo.HasInitializedScope">
      <summary>
            Gets a value indicating whether this instance has initialized scope.
            </summary>
      <value>
        <c>true</c> if this instance has initialized scope; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo">
      <summary>
            Base <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /> implementation. It's up 
            to derived classes to provide a correct implementation 
            of <c>CurrentStack</c> only
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.RegisterScope(Castle.ActiveRecord.ISessionScope)">
      <summary>
            Registers the scope.
            </summary>
      <param name="scope">The scope.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.GetRegisteredScope">
      <summary>
            Gets the registered scope.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.UnRegisterScope(Castle.ActiveRecord.ISessionScope)">
      <summary>
            Unregister the scope.
            </summary>
      <param name="scope">The scope.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.CurrentStack">
      <summary>
            Gets the current stack.
            </summary>
      <value>The current stack.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.HasInitializedScope">
      <summary>
            Gets a value indicating whether this instance has initialized scope.
            </summary>
      <value>
        <c>true</c> if this instance has initialized scope; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope">
      <summary>
            Still very experimental and it's not bullet proof
            for all situations
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.#ctor(System.Data.IDbConnection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope" /> class.
            </summary>
      <param name="connection">The connection.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.#ctor(System.Data.IDbConnection,Castle.ActiveRecord.FlushAction)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope" /> class.
            </summary>
      <param name="connection">The connection.</param>
      <param name="flushAction">The flush action.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.RegisterSession(System.Object,NHibernate.ISession)">
      <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            just created one. So it registers the session created
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.IsKeyKnown(System.Object)" /></summary>
      <param name="key">an object instance</param>
      <param name="session">An instance of <c>ISession</c></param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.IsKeyKnown(System.Object)">
      <summary>
            This method is invoked when the
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key.
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.RegisterSession(System.Object,NHibernate.ISession)" /></summary>
      <param name="key">an object instance</param>
      <returns>
        <c>true</c> if the key exists within this scope instance
            </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.GetSession(System.Object)">
      <summary>
            This method should return the session instance associated with the key.
            </summary>
      <param name="key">an object instance</param>
      <returns>
            the session instance or null if none was found
            </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.PerformDisposal(System.Collections.ICollection)">
      <summary>
            Performs the disposal.
            </summary>
      <param name="sessions">The sessions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.OpenSession(NHibernate.ISessionFactory,NHibernate.IInterceptor)">
      <summary>
            If the <see cref="P:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.WantsToCreateTheSession" /> returned
            <c>true</c> then this method is invoked to allow
            the scope to create a properly configured session
            </summary>
      <param name="sessionFactory">From where to open the session</param>
      <param name="interceptor">the NHibernate interceptor</param>
      <returns>the newly created session</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.WantsToCreateTheSession">
      <summary>
            We want to be in charge of creating the session
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.ActiveRecord.FlushAction">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.FlushAction.Auto">
      <summary>
            Original behavior. Changes are persisted at the 
            end or before some queries.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.FlushAction.Never">
      <summary>
            Flush need to be controlled manually. Best choice
            for readonly operations
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.HybridWebThreadScopeInfo">
      <summary>
            This <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /> implementation will first try to get the current scope from the current 
            request, and if not found, will use a thread lcoal scope.
            </summary>
      <remarks>
            This is used for scenarios where most of the you need per request scope, but you also does some work outside a 
            request (in a thread pool thread, for instnace).
            </remarks>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.HybridWebThreadScopeInfo.CurrentStack">
      <summary>
            Gets the current stack.
            </summary>
      <value>The current stack.</value>
    </member>
    <member name="T:Castle.ActiveRecord.SessionScopeType">
      <summary>
            Define session scope types
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.SessionScopeType.Undefined">
      <summary>
            Undefined type of session scope.
            This value probably should never exist
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.SessionScopeType.Simple">
      <summary>
            Simple - non transactional session scope
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.SessionScopeType.Transactional">
      <summary>
            Transactional session scope
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.SessionScopeType.Custom">
      <summary>
            Custom implementation of session scope.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException">
      <summary>
            This exception is raised when something went wrong with the scope management.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
      <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
    </member>
    <member name="T:Castle.ActiveRecord.SessionScope">
      <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope" /> to 
            augment performance by caching the session, thus
            avoiding too much opens/flushes/closes.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.SessionScope.#ctor(Castle.ActiveRecord.FlushAction,Castle.ActiveRecord.SessionScopeType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.SessionScope" /> class.
            </summary>
      <param name="flushAction">The flush action.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.SessionScope.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.SessionScope" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.SessionScope.#ctor(Castle.ActiveRecord.FlushAction)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.SessionScope" /> class.
            </summary>
      <param name="flushAction">The flush action.</param>
    </member>
    <member name="M:Castle.ActiveRecord.SessionScope.Dispose(System.Boolean)">
      <summary>
            Disposes the specified discard changes.
            </summary>
      <param name="discardChanges">if set to <c>true</c> [discard changes].</param>
    </member>
    <member name="M:Castle.ActiveRecord.SessionScope.PerformDisposal(System.Collections.ICollection)">
      <summary>
            Performs the disposal.
            </summary>
      <param name="sessions">The sessions.</param>
    </member>
    <member name="P:Castle.ActiveRecord.SessionScope.Current">
      <summary>
            Gets the current scope
            </summary>
      <value>The current.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor">
      <summary>
            Class to allow scopes to reach the implementation
            of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" />. Also implements 
            the <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /> delegating the calls to 
            the scope set.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.GetRegisteredScope">
      <summary>
            Gets the registered scope.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.RegisterScope(Castle.ActiveRecord.ISessionScope)">
      <summary>
            Registers the scope.
            </summary>
      <param name="scope">The scope.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.UnRegisterScope(Castle.ActiveRecord.ISessionScope)">
      <summary>
            Unregister the scope.
            </summary>
      <param name="scope">The scope.</param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.Instance">
      <summary>
            Gets the single instance.
            </summary>
      <value>The instance.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.ScopeInfo">
      <summary>
            Gets or sets the scope info.
            </summary>
      <value>The scope info.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.CurrentStack">
      <summary>
            Gets the current stack.
            </summary>
      <value>The current stack.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.HasInitializedScope">
      <summary>
            Gets a value indicating whether this instance has initialized scope.
            </summary>
      <value>
        <c>true</c> if this instance has initialized scope; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.ThreadScopeInfo">
      <summary>
            This <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /> implementation will first get the current scope from the current 
            thread. Do NOT use on web scenario (web applications or web services).
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeInfo.CurrentStack">
      <summary>
            Gets the current stack.
            </summary>
      <value>The current stack.</value>
    </member>
    <member name="T:Castle.ActiveRecord.TransactionMode">
      <summary>
            Defines the transaction scope behavior
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.TransactionMode.Inherits">
      <summary>
            Inherits a transaction previously create on 
            the current context.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.TransactionMode.New">
      <summary>
            Always create an isolated transaction context.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.OnDispose">
      <summary>
            Governs the <see cref="T:Castle.ActiveRecord.TransactionScope" /> behavior 
            on dispose if neither <see cref="M:Castle.ActiveRecord.TransactionScope.VoteCommit" />
            nor <see cref="M:Castle.ActiveRecord.TransactionScope.VoteRollBack" /> was called
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OnDispose.Commit">
      <summary>
            Should commit the transaction, unless <see cref="M:Castle.ActiveRecord.TransactionScope.VoteRollBack" />
            was called before the disposing the scope (this is the default behavior)
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.OnDispose.Rollback">
      <summary>
            Should rollback the transaction, unless <see cref="M:Castle.ActiveRecord.TransactionScope.VoteCommit" />
            was called before the disposing the scope
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.TransactionScope">
      <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope" /> to 
            provide transaction semantics
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.OnDispose)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope" /> class.
            </summary>
      <param name="onDisposeBehavior">The on dispose behavior.</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.TransactionMode)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope" /> class.
            </summary>
      <param name="mode">Whatever to create a new transaction or inherits an existing one</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.TransactionMode,Castle.ActiveRecord.OnDispose)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope" /> class.
            </summary>
      <param name="mode">Whatever to create a new transaction or inherits an existing one</param>
      <param name="onDisposeBehavior">The on dispose behavior.</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.TransactionMode,System.Data.IsolationLevel,Castle.ActiveRecord.OnDispose)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope" /> class.
            </summary>
      <param name="mode">Whatever to create a new transaction or inherits an existing one</param>
      <param name="isolationLevel">The transaction isolation level.</param>
      <param name="onDisposeBehavior">The on dispose behavior.</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.VoteRollBack">
      <summary>
            Votes to roll back the transaction
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.VoteCommit">
      <summary>
            Votes to commit the transaction
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.IsKeyKnown(System.Object)">
      <summary>
            This method is invoked when the
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key.
            <seealso cref="M:Castle.ActiveRecord.TransactionScope.RegisterSession(System.Object,NHibernate.ISession)" /></summary>
      <param name="key">an object instance</param>
      <returns>
        <c>true</c> if the key exists within this scope instance
            </returns>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.RegisterSession(System.Object,NHibernate.ISession)">
      <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" />
            just created one. So it registers the session created
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it
            <seealso cref="M:Castle.ActiveRecord.TransactionScope.IsKeyKnown(System.Object)" /></summary>
      <param name="key">an object instance</param>
      <param name="session">An instance of <c>ISession</c></param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.GetSession(System.Object)">
      <summary>
            This method should return the session instance associated with the key.
            </summary>
      <param name="key">an object instance</param>
      <returns>
            the session instance or null if none was found
            </returns>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.EnsureHasTransaction(NHibernate.ISession)">
      <summary>
            Ensures that a transaction exist, creating one if neccecary
            </summary>
      <param name="session">The session.</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.Initialize(NHibernate.ISession)">
      <summary>
            Initializes the current transaction scope using the session
            </summary>
      <param name="session">The session.</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.PerformDisposal(System.Collections.ICollection)">
      <summary>
            Dispose of this scope
            </summary>
      <param name="sessions">The sessions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.DiscardSessions(System.Collections.ICollection)">
      <summary>
            Discards the sessions.
            </summary>
      <param name="sessions">The sessions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.TransactionScope.RaiseOnCompleted">
      <summary>
            Raises the on completed event
            </summary>
    </member>
    <member name="E:Castle.ActiveRecord.TransactionScope.OnTransactionCompleted">
      <summary>
            This event is raised when a transaction is completed
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Scopes.WebThreadScopeInfo">
      <summary>
            This <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /> implementation will first get the current scope from the current 
            request, thus implementing a Session Per Request pattern.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Scopes.WebThreadScopeInfo.CurrentStack">
      <summary>
            Gets the current stack.
            </summary>
      <value>The current stack.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.IValidator">
      <summary>
            Define the basic contract for validators
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.IValidator.Initialize(System.Reflection.PropertyInfo)">
      <summary>
            Implementors should perform any initialization logic
            </summary>
      <param name="property">The target property</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.IValidator.Perform(System.Object)">
      <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
      <param name="instance">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.IValidator.Perform(System.Object,System.Object)">
      <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IValidator.Property">
      <summary>
            The target property
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.IValidator.ErrorMessage">
      <summary>
            The error message to be displayed if the validation fails
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.AbstractValidator">
      <summary>
            Abstract <see cref="T:Castle.ActiveRecord.Framework.IValidator" /> implementation
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.GetFieldOrPropertyValue(System.Object,System.String)">
      <summary>
            Obtains the value of a property or field on a specific instance.
            </summary>
      <param name="instance">The instance to inspect.</param>
      <param name="fieldOrPropertyName">The name of the field or property to inspect.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Initialize(System.Reflection.PropertyInfo)">
      <summary>
            Implementors should perform any initialization logic
            </summary>
      <param name="property">The target property</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Perform(System.Object)">
      <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
      <param name="instance">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Perform(System.Object,System.Object)">
      <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.BuildErrorMessage">
      <summary>
            Builds the error message.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Property">
      <summary>
            The target property
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.AbstractValidator.ErrorMessage">
      <summary>
            The error message to be displayed if the validation fails
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.ConfirmationValidator">
      <summary>
            Validates that a property and a matching property are the same.
            This it used when you need to accept two identical inputs from the user, for instnace, 
            a password and its confirmation.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.ConfirmationValidator.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Validators.ConfirmationValidator" /> class.
            </summary>
      <param name="confirmationFieldOrProperty">The confirmation field or property.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.ConfirmationValidator.Perform(System.Object,System.Object)">
      <summary>
            Check that the confirmation property has the same value as this property.
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.ConfirmationValidator.BuildErrorMessage">
      <summary>
            Builds the default error message.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.ConfirmationValidator.ConfirmationFieldOrProperty">
      <summary>
            Gets the confirmation field or property.
            </summary>
      <value>The confirmation field or property.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.CreditCardValidator">
      <summary>
            This validator validate that the is a valid credit card number in:
            <list type="unordered"><item>Amex </item><item> DinersClub </item><item> Discover </item><item> Discover </item><item> enRoute </item><item> JCB </item><item> MasterCard </item><item> VISA</item></list>
            It is possible to specify more than a single card type.
            You can also specify exceptions for test cards.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType">
      <summary>
            Define the known card types
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Validators.CreditCardValidator" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType)">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="allowedTypes">The card types to accept.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.#ctor(System.String[])">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.#ctor(Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType,System.String[])">
      <summary>
            Initializes a new credit card validator.
            </summary>
      <param name="allowedTypes">The card types to accept.</param>
      <param name="exceptions">An array of card numbers to skip checking for (eg. gateway test numbers). Only digits should be provided for the exceptions.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.Perform(System.Object,System.Object)">
      <summary>
            Validate that the propety value matches a valid (formatted) credit card
            Note: null values are consider OK always, combine with <see cref="T:Castle.ActiveRecord.Framework.Validators.NullCheckValidator" /> if required.
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.BuildErrorMessage">
      <summary>
            Builds the error message.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.AllowedTypes">
      <summary>
            Gets the allowed credit card types.
            </summary>
      <value>The <see cref="T:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.CardType" /> representing the allowed types.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.CreditCardValidator.Exceptions">
      <summary>
            An array of card numbers to skip checking for (eg. gateway test numbers).
            </summary>
      <value>A <see cref="T:System.Array" />representing the card numbers to skip checking.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator">
      <summary>
            Validate a property using regular expression
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator" /> class.
            </summary>
      <param name="expression">The expression.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator" /> class.
            </summary>
      <param name="expression">The expression.</param>
      <param name="options">The regular expression options.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator.Perform(System.Object,System.Object)">
      <summary>
            Validate that the property value match the given regex
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator.BuildErrorMessage">
      <summary>
            Builds the error message.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.RegularExpressionValidator.RegexRule">
      <summary>
            Gets the regular expression rule.
            </summary>
      <value>The regular expression rule.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.EmailValidator">
      <summary>
            Validate that this is a valid (formatted) email using regex
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.Validators.EmailValidator.emailRule">
      <summary>
            From http://www.codeproject.com/aspnet/Valid_Email_Addresses.asp
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.EmailValidator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Validators.EmailValidator" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.EmailValidator.BuildErrorMessage">
      <summary>
            Builds the error message.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator">
      <summary>
            Validate that the property's value is unique in the database when saved
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.Perform(System.Object,System.Object)">
      <summary>
            Perform the check that the property value is unqiue in the table
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.BuildErrorMessage">
      <summary>
            Builds the error message when the property value is not unique
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.LengthValidator">
      <summary>
            Ensures that a property's string representation 
            is within the desired length limitations.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.LengthValidator.#ctor(System.Int32)">
      <summary>
            Initializes a new exact length validator.
            </summary>
      <param name="exactLength">The exact length required.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.LengthValidator.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new range based length validator.
            </summary>
      <param name="minLength">The minimum length, or <c>int.MinValue</c> if this should not be tested.</param>
      <param name="maxLength">The maximum length, or <c>int.MaxValue</c> if this should not be tested.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.LengthValidator.Perform(System.Object,System.Object)">
      <summary>
            Validate that the property value matches the length requirements.
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.LengthValidator.BuildErrorMessage">
      <summary>
            Builds the error message.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.LengthValidator.ExactLength">
      <summary>
            Gets the exact length of the field.
            </summary>
      <value>The exact length of the field.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.LengthValidator.MinLength">
      <summary>
            Gets the minimum length.
            </summary>
      <value>The minimum length.</value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.Validators.LengthValidator.MaxLength">
      <summary>
            Gets the maximun length.
            </summary>
      <value>The maximun length.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Validators.NullCheckValidator">
      <summary>
            Ensures that a property was 
            filled with some value
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.NullCheckValidator.Perform(System.Object,System.Object)">
      <summary>
            Check that this property has a value that is not null or empty (if string)
            </summary>
      <param name="instance">
      </param>
      <param name="fieldValue">
      </param>
      <returns>
        <c>true</c> if the field is OK</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Validators.NullCheckValidator.BuildErrorMessage">
      <summary>
            Builds the error message.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.ActiveRecord.NHibernateDelegate">
      <summary>
            Allow custom executions using the NHibernate's ISession.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordHooksBase">
      <summary>
            Base class for ActiveRecord entities
            that are interested in NHibernate's hooks.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeSave(System.Collections.IDictionary)">
      <summary>
            Hook to change the object state
            before saving it.
            </summary>
      <param name="state">
      </param>
      <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeLoad(System.Collections.IDictionary)">
      <summary>
            Hook to transform the read data 
            from the database before populating 
            the object instance
            </summary>
      <param name="adapter">
      </param>
      <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeDelete(System.Collections.IDictionary)">
      <summary>
            Hook to perform additional tasks 
            before removing the object instance representation
            from the database.
            </summary>
      <param name="adapter">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.PreFlush">
      <summary>
            Called before a flush
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.PostFlush">
      <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.IsUnsaved">
      <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
      <remarks>
            The return value determines if the object is saved
            <list><item><c>true</c> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item><item><c>false</c> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item><item><c>null</c> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item></list></remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.FindDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
      <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
      <remarks>
        <list>
          <item>an array of property indicies - the entity is dirty</item>
          <item>an empty array - the entity is not dirty</item>
          <item>
            <c>null</c> - use Hibernate's default dirty-checking algorithm</item>
        </list>
      </remarks>
      <param name="id">
      </param>
      <param name="previousState">
      </param>
      <param name="currentState">
      </param>
      <param name="types">
      </param>
      <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnFlushDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
      <summary>
      </summary>
      <param name="id">
      </param>
      <param name="previousState">
      </param>
      <param name="currentState">
      </param>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnSave">
      <summary>
            Lifecycle method invoked during Save of the entity
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnUpdate">
      <summary>
            Lifecycle method invoked during Update of the entity
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnDelete">
      <summary>
            Lifecycle method invoked during Delete of the entity
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnLoad(System.Object)">
      <summary>
            Lifecycle method invoked during Load of the entity
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordBase">
      <summary>
            Base class for all ActiveRecord classes. Implements 
            all the functionality to simplify the code on the 
            subclasses.
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ActiveRecordBase.holder">
      <summary>
            The global holder for the session factories.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
      <summary>
            Internally used
            </summary>
      <param name="arType">The type.</param>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.GetModel(System.Type)">
      <summary>
            Internally used
            </summary>
      <param name="arType">The type.</param>
      <returns>An <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create(System.Object)">
      <summary>
            Creates (Saves) a new instance to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be created on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.CreateAndFlush(System.Object)">
      <summary>
            Creates (Saves) a new instance to the database and flushes the session.
            </summary>
      <param name="instance">The ActiveRecord instance to be created on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalCreate(System.Object,System.Boolean)">
      <summary>
            Creates (Saves) a new instance to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be created on the database</param>
      <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete(System.Object)">
      <summary>
            Deletes the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAndFlush(System.Object)">
      <summary>
            Deletes the instance from the database and flushes the session.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalDelete(System.Object,System.Boolean)">
      <summary>
            Deletes the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
      <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Replicate(System.Object,NHibernate.ReplicationMode)">
      <summary>
            From NHibernate documentation: 
            Persist all reachable transient objects, reusing the current identifier 
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
      <param name="instance">The instance.</param>
      <param name="replicationMode">The replication mode.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Refresh(System.Object)">
      <summary>
            Refresh the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be reloaded</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAll(System.Type)">
      <summary>
            Deletes all rows for the specified ActiveRecord type
            </summary>
      <remarks>
            This method is usually useful for test cases.
            </remarks>
      <param name="type">ActiveRecord type on which the rows on the database should be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAll(System.Type,System.String)">
      <summary>
            Deletes all rows for the specified ActiveRecord type that matches
            the supplied HQL condition
            </summary>
      <remarks>
            This method is usually useful for test cases.
            </remarks>
      <param name="type">ActiveRecord type on which the rows on the database should be deleted</param>
      <param name="where">HQL condition to select the rows to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAll(System.Type,System.Collections.IEnumerable)">
      <summary>
            Deletes all <paramref name="targetType" /> objects, based on the primary keys
            supplied on <paramref name="pkValues" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="pkValues">A list of primary keys</param>
      <returns>The number of objects deleted</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update(System.Object)">
      <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be updated on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.UpdateAndFlush(System.Object)">
      <summary>
            Persists the modification on the instance
            state to the database and flushes the session.
            </summary>
      <param name="instance">The ActiveRecord instance to be updated on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalUpdate(System.Object,System.Boolean)">
      <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be updated on the database</param>
      <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save(System.Object)">
      <summary>
            Saves the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create" />
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update" /> instead.
            </para></summary>
      <param name="instance">The ActiveRecord instance to be saved</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveAndFlush(System.Object)">
      <summary>
            Saves the instance to the database and flushes the session. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create" />
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update" /> instead.
            </para></summary>
      <param name="instance">The ActiveRecord instance to be saved</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalSave(System.Object,System.Boolean)">
      <summary>
            Saves the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create" />
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update" /> instead.
            </para></summary>
      <param name="instance">The ActiveRecord instance to be saved</param>
      <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
      <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
      <param name="targetType">The target ActiveRecordType</param>
      <param name="call">The delegate instance</param>
      <param name="instance">The ActiveRecord instance</param>
      <returns>Whatever is returned by the delegate invocation</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.EnumerateQuery(Castle.ActiveRecord.IActiveRecordQuery)">
      <summary>
            Enumerates the query
            Note: only use if you expect most of the values to exist on the second level cache.
            </summary>
      <param name="query">The query.</param>
      <returns>An <see cref="T:System.Collections.IEnumerable" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.ExecuteQuery(Castle.ActiveRecord.IActiveRecordQuery)">
      <summary>
            Executes the query.
            </summary>
      <param name="query">The query.</param>
      <returns>The query result.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type)">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <example>
        <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountAllUsers()
              {
                return Count(typeof(User));
              }
            }
            </code>
      </example>
      <param name="targetType">The target type.</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type,System.String,System.Object[])">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <example>
        <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountAllUsersLocked()
              {
                return Count(typeof(User), "IsLocked = ?", true);
              }
            }
            </code>
      </example>
      <param name="targetType">The target type.</param>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <param name="targetType">The target type.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <param name="targetType">The target type.</param>
      <param name="detachedCriteria">The criteria expression</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type)">
      <summary>
            Check if there is any records in the db for the target type
            </summary>
      <param name="targetType">The target type.</param>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,System.String,System.Object[])">
      <summary>
            Check if there is any records in the db for the target type
            </summary>
      <param name="targetType">The target type.</param>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,System.Object)">
      <summary>
            Check if the <paramref name="id" /> exists in the database.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="id">The id to check on</param>
      <returns>
        <c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="criteria">The criteria expression</param>
      <returns>
        <c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="detachedCriteria">The criteria expression</param>
      <returns>
        <c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[])">
      <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
      <param name="targetType">The target type.</param>
      <param name="detachedCriteria">The criteria.</param>
      <param name="orders">An <see cref="T:System.Array" /> of <see cref="T:NHibernate.Expression.Order" /> objects.</param>
      <returns>The <see cref="T:System.Array" /> of results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type)">
      <summary>
            Returns all instances found for the specified type.
            </summary>
      <param name="targetType">The target type.</param>
      <returns>The <see cref="T:System.Array" /> of results</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for the specified type 
            using sort orders and criteria.
            </summary>
      <param name="targetType">The The target type.</param>
      <param name="orders">An <see cref="T:System.Array" /> of <see cref="T:NHibernate.Expression.Order" /> objects.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The <see cref="T:System.Array" /> of results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for the specified type 
            using criteria.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The <see cref="T:System.Array" /> of results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.Object)">
      <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
      <param name="targetType">The target type</param>
      <param name="property">A property name (not a column name)</param>
      <param name="value">The value to be equals to</param>
      <returns>The <see cref="T:System.Array" /> of results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.String,System.Object)">
      <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
      <param name="targetType">The target type</param>
      <param name="orderByColumn">The column name to be ordered ASC</param>
      <param name="property">A property name (not a column name)</param>
      <param name="value">The value to be equals to</param>
      <returns>The <see cref="T:System.Array" /> of results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object)">
      <summary>
            Finds an object instance by an unique ID
            </summary>
      <param name="targetType">The AR subclass type</param>
      <param name="id">ID value</param>
      <returns>The object instance.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
      <summary>
            Finds an object instance by an unique ID
            </summary>
      <param name="targetType">The AR subclass type</param>
      <param name="id">ID value</param>
      <param name="throwOnNotFound">
        <c>true</c> if you want to catch an exception 
            if the object is not found</param>
      <returns>The object instance.</returns>
      <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="targetType">The target type.</param>
      <param name="detachedCriteria">The criteria.</param>
      <param name="orders">The sort order - used to determine which record is the first one.</param>
      <returns>A <c>targetType</c> instance or <c>null.</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="targetType">The target type</param>
      <param name="orders">The sort order - used to determine which record is the first one</param>
      <param name="criteria">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="targetType">The target type</param>
      <param name="criteria">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindOne(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /></summary>
      <param name="targetType">The target type</param>
      <param name="criteria">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindOne(System.Type,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /></summary>
      <param name="targetType">The target type</param>
      <param name="criteria">The criteria</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
      <param name="targetType">The target type.</param>
      <param name="firstResult">The number of the first row to retrieve.</param>
      <param name="maxResults">The maximum number of results retrieved.</param>
      <param name="orders">An <see cref="T:System.Array" /> of <see cref="T:NHibernate.Expression.Order" /> objects.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The sliced query results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.DetachedCriteria)">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
      <param name="targetType">The target type.</param>
      <param name="firstResult">The number of the first row to retrieve.</param>
      <param name="maxResults">The maximum number of results retrieved.</param>
      <param name="orders">An <see cref="T:System.Array" /> of <see cref="T:NHibernate.Expression.Order" /> objects.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The sliced query results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
      <param name="targetType">The target type.</param>
      <param name="firstResult">The number of the first row to retrieve.</param>
      <param name="maxResults">The maximum number of results retrieved.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The sliced query results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
      <param name="targetType">The target type.</param>
      <param name="firstResult">The number of the first row to retrieve.</param>
      <param name="maxResults">The maximum number of results retrieved.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The sliced query results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(Castle.ActiveRecord.NHibernateDelegate)">
      <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
      <param name="call">The delegate instance</param>
      <returns>Whatever is returned by the delegate invocation</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save">
      <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
      <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveAndFlush">
      <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
      <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create">
      <summary>
            Creates (Saves) a new instance to the database.
            </summary>
      <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.CreateAndFlush">
      <summary>
            Creates (Saves) a new instance to the database.
            </summary>
      <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update">
      <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
      <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.UpdateAndFlush">
      <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
      <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete">
      <summary>
            Deletes the instance from the database.
            </summary>
      <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAndFlush">
      <summary>
            Deletes the instance from the database.
            </summary>
      <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope" /> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.Refresh">
      <summary>
            Refresh the instance from the database.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase.ToString">
      <summary>
            Return the type of the object with its PK value.
            Useful for logging/debugging
            </summary>
      <returns>A string representation of this object.</returns>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordBase`1">
      <summary>
            Base class for all ActiveRecord Generic classes. 
            Implements all the functionality to simplify the code on the subclasses.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Create(`0)">
      <summary>
            Creates (Saves) a new instance to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be created on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Delete(`0)">
      <summary>
            Deletes the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll">
      <summary>
            Deletes all rows for the specified ActiveRecord type
            </summary>
      <remarks>
            This method is usually useful for test cases.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll(System.String)">
      <summary>
            Deletes all rows for the specified ActiveRecord type that matches
            the supplied HQL condition
            </summary>
      <remarks>
            This method is usually useful for test cases.
            </remarks>
      <param name="where">HQL condition to select the rows to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll(System.Collections.IEnumerable)">
      <summary>
            Deletes all <typeparamref name="T" /> objects, based on the primary keys
            supplied on <paramref name="pkValues" />.
            </summary>
      <returns>The number of objects deleted</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Refresh(`0)">
      <summary>
            Refresh the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be reloaded</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Update(`0)">
      <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be updated on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Save(`0)">
      <summary>
            Saves the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase`1.Create(`0)" />
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase`1.Update(`0)" /> instead.
            </para></summary>
      <param name="instance">The ActiveRecord instance to be saved</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Execute(Castle.ActiveRecord.NHibernateDelegate,System.Object)">
      <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
      <param name="call">The delegate instance</param>
      <param name="instance">The ActiveRecord instance</param>
      <returns>Whatever is returned by the delegate invocation</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.ExecuteQuery2``1(Castle.ActiveRecord.IActiveRecordQuery{``0})">
      <summary>
            Executes the query and return a strongly typed result
            </summary>
      <param name="query">The query.</param>
      <returns>The query result.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count">
      <summary>
            Returns the number of records of <typeparamref name="T" /> in the database
            </summary>
      <example>
        <code escaped="true">
            [ActiveRecord]
            public class User : ActiveRecordBase&lt;User&gt;
            {
              ...
              
              public static int CountAllUsers()
              {
                return Count(); // Equivalent to: Count(typeof(User));
              }
            }
            </code>
      </example>
      <returns>The count query result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count(System.String,System.Object[])">
      <summary>
            Returns the number of records of <typeparamref name="T" /> in the database
            </summary>
      <example>
        <code escaped="true">
            [ActiveRecord]
            public class User : ActiveRecordBase&lt;User&gt;
            {
              ...
              
              public static int CountAllUsersLocked()
              {
                return Count("IsLocked = ?", true); // Equivalent to: Count(typeof(User), "IsLocked = ?", true);
              }
            }
            </code>
      </example>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count(NHibernate.Expression.ICriterion[])">
      <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
      <param name="criteria">The criteria expression</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count(NHibernate.Expression.DetachedCriteria)">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <param name="detachedCriteria">The criteria expression</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists">
      <summary>
            Check if there is any records in the db for <typeparamref name="T" /></summary>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists(System.String,System.Object[])">
      <summary>
            Check if there is any records in the db for <typeparamref name="T" /></summary>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists``1(``0)">
      <summary>
            Check if the <paramref name="id" /> exists in the database.
            </summary>
      <typeparam name="PkType">The <c>System.Type</c> of the PrimaryKey</typeparam>
      <param name="id">The id to check on</param>
      <returns>
        <c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists(NHibernate.Expression.ICriterion[])">
      <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
      <param name="criteria">The criteria expression</param>
      <returns>
        <c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists(NHibernate.Expression.DetachedCriteria)">
      <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
      <param name="detachedCriteria">The criteria expression</param>
      <returns>
        <c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[])">
      <summary>
            Returns all the instances that match the detached criteria.
            </summary>
      <param name="criteria">Detached criteria</param>
      <param name="orders">Optional ordering</param>
      <returns>All entities that match the criteria</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll">
      <summary>
            Returns all instances found for <typeparamref name="T" /></summary>
      <returns>An <see cref="T:System.Array" /> of <typeparamref name="T" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Expression.Order,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for the specified type 
            using sort orders and criteria.
            </summary>
      <param name="order">An <see cref="T:NHibernate.Expression.Order" /> object.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The <see cref="T:System.Array" /> of results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for <typeparamref name="T" />
            using sort orders and criteria.
            </summary>
      <param name="orders">
      </param>
      <param name="criteria">
      </param>
      <returns>An <see cref="T:System.Array" /> of <typeparamref name="T" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for <typeparamref name="T" />
            using criteria.
            </summary>
      <param name="criteria">
      </param>
      <returns>An <see cref="T:System.Array" /> of <typeparamref name="T" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAllByProperty(System.String,System.Object)">
      <summary>
            Finds records based on a property value
            </summary>
      <param name="property">A property name (not a column name)</param>
      <param name="value">The value to be equals to</param>
      <returns>An <see cref="T:System.Array" /> of <typeparamref name="T" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAllByProperty(System.String,System.String,System.Object)">
      <summary>
            Finds records based on a property value
            </summary>
      <param name="orderByColumn">The column name to be ordered ASC</param>
      <param name="property">A property name (not a column name)</param>
      <param name="value">The value to be equals to</param>
      <returns>An <see cref="T:System.Array" /> of <typeparamref name="T" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Find(System.Object)">
      <summary>
            Finds an object instance by an unique ID 
            </summary>
      <param name="id">ID value</param>
      <exception cref="T:NHibernate.ObjectNotFoundException">if the row is not found</exception>
      <returns>T</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.TryFind(System.Object)">
      <summary>
            Finds an object instance by an unique ID.
            If the row is not found this method will not throw an exception.
            </summary>
      <param name="id">ID value</param>
      <returns>A <typeparamref name="T" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindByPrimaryKey(System.Object)">
      <summary>
            Finds an object instance by an unique ID for <typeparamref name="T" /></summary>
      <param name="id">ID value</param>
      <returns>A <typeparamref name="T" /></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindByPrimaryKey(System.Object,System.Boolean)">
      <summary>
            Finds an object instance by a unique ID for <typeparamref name="T" /></summary>
      <param name="id">ID value</param>
      <param name="throwOnNotFound">
        <c>true</c> if you want to catch an exception 
            if the object is not found</param>
      <returns>A <typeparamref name="T" /></returns>
      <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[])">
      <summary>
            Searches and returns the first row for <typeparamref name="T" />.
            </summary>
      <param name="criteria">Detached criteria.</param>
      <param name="orders">The sort order - used to determine which record is the first one.</param>
      <returns>A <c>targetType</c> instance or <c>null</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Expression.Order,NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row for <typeparamref name="T" /></summary>
      <param name="order">The sort order - used to determine which record is the first one</param>
      <param name="criteria">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row for <typeparamref name="T" /></summary>
      <param name="orders">The sort order - used to determine which record is the first one</param>
      <param name="criteria">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row for <typeparamref name="T" /></summary>
      <param name="criteria">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindOne(NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /></summary>
      <param name="criteria">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindOne(NHibernate.Expression.DetachedCriteria)">
      <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /></summary>
      <param name="criteria">The criteria</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
      <param name="firstResult">The number of the first row to retrieve.</param>
      <param name="maxResults">The maximum number of results retrieved.</param>
      <param name="orders">An <see cref="T:System.Array" /> of <see cref="T:NHibernate.Expression.Order" /> objects.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The sliced query results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
      <param name="firstResult">The number of the first row to retrieve.</param>
      <param name="maxResults">The maximum number of results retrieved.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The sliced query results.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
      <param name="firstResult">The number of the first row to retrieve.</param>
      <param name="maxResults">The maximum number of results retrieved.</param>
      <param name="orders">An <see cref="T:System.Array" /> of <see cref="T:NHibernate.Expression.Order" /> objects.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The sliced query results.</returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.ActiveRecordException">
      <summary>
            This exception is raised when Active Record encounters a problem
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ActiveRecordException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ActiveRecordException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ActiveRecordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
      <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException">
      <summary>
            Exception thrown when an error is detected on the ActiveRecord initialization phase.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ActiveRecordInitializationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ActiveRecordInitializationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ActiveRecordInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
      <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordMediator">
      <summary>
            Allow programmers to use the 
            ActiveRecord functionality without direct reference
            to <see cref="T:Castle.ActiveRecord.ActiveRecordBase" /></summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
      <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
      <param name="targetType">The target ActiveRecordType</param>
      <param name="call">The delegate instance</param>
      <param name="instance">The ActiveRecord instance</param>
      <returns>Whatever is returned by the delegate invocation</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
      <summary>
            Finds an object instance by its primary key.
            </summary>
      <param name="targetType">The AR subclass type</param>
      <param name="id">ID value</param>
      <param name="throwOnNotFound">
        <c>true</c> if you want an exception to be thrown
            if the object is not found</param>
      <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object)">
      <summary>
            Finds an object instance by its primary key.
            </summary>
      <param name="targetType">The AR subclass type</param>
      <param name="id">ID value</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="targetType">The target type</param>
      <param name="orders">The sort order - used to determine which record is the first one</param>
      <param name="criterias">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="targetType">The target type</param>
      <param name="criterias">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindOne(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /></summary>
      <param name="targetType">The target type</param>
      <param name="criterias">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindOne(System.Type,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException" /></summary>
      <param name="targetType">The target type</param>
      <param name="criteria">The criteria</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.DetachedCriteria)">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.DetachedCriteria)">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type)">
      <summary>
            Returns all instances found for the specified type.
            </summary>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
      <param name="targetType">
      </param>
      <param name="orders">
      </param>
      <param name="criterias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
      <param name="targetType">
      </param>
      <param name="criterias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Expression.DetachedCriteria,NHibernate.Expression.Order[])">
      <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAllByProperty(System.Type,System.String,System.Object)">
      <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
      <param name="targetType">The target type</param>
      <param name="property">A property name (not a column name)</param>
      <param name="value">The value to be equals to</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAllByProperty(System.Type,System.String,System.String,System.Object)">
      <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
      <param name="targetType">The target type</param>
      <param name="orderByColumn">The column name to be ordered ASC</param>
      <param name="property">A property name (not a column name)</param>
      <param name="value">The value to be equals to</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAll(System.Type)">
      <summary>
            Deletes all entities of the specified type (and their inheritors)
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAll(System.Type,System.String)">
      <summary>
            Deletes all entities of specified type that match the HQL where clause
            </summary>
      <param name="type">The type.</param>
      <param name="where">The where.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAll(System.Type,System.Collections.IEnumerable)">
      <summary>
            Deletes all <paramref name="targetType" /> objects, based on the primary keys
            supplied on <paramref name="pkValues" />.
            </summary>
      <param name="targetType">The target ActiveRecord type</param>
      <param name="pkValues">A list of primary keys</param>
      <returns>The number of objects deleted</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.EnumerateQuery(Castle.ActiveRecord.IActiveRecordQuery)">
      <summary>
            Enumerates the query.
            Note: Only use if you expect most of the values to be on the second level cache
            </summary>
      <param name="q">The query</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.ExecuteQuery(Castle.ActiveRecord.IActiveRecordQuery)">
      <summary>
            Executes the query
            </summary>
      <param name="q">The query</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Count(System.Type)">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <example>
        <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountUsers()
              {
                return Count(typeof(User));
              }
            }
            </code>
      </example>
      <param name="targetType">Type of the target.</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Count(System.Type,System.String,System.Object[])">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <example>
        <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountUsersLocked()
              {
                return Count(typeof(User), "IsLocked = ?", true);
              }
            }
            </code>
      </example>
      <param name="targetType">Type of the target.</param>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Count(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <param name="targetType">The target type.</param>
      <param name="criteria">The criteria expression</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type)">
      <summary>
            Check if there is any records in the db for the target type
            </summary>
      <param name="targetType">Type of the target.</param>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,System.String,System.Object[])">
      <summary>
            Check if there is any records in the db for the target type
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,System.Object)">
      <summary>
            Check if the <paramref name="id" /> exists in the database.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="id">The id to check on</param>
      <returns>
        <c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,NHibernate.Expression.ICriterion[])">
      <summary>
            Check if any instance matches the criteria.
            </summary>
      <returns>
        <c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Save(System.Object)">
      <summary>
            Saves the instance to the database
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SaveAndFlush(System.Object)">
      <summary>
            Saves the instance to the database and flushes the session. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordMediator.Create(System.Object)" />
            or <see cref="M:Castle.ActiveRecord.ActiveRecordMediator.Update(System.Object)" /> instead.
            </para></summary>
      <param name="instance">The ActiveRecord instance to be saved</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Create(System.Object)">
      <summary>
            Creates (Saves) a new instance to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.CreateAndFlush(System.Object)">
      <summary>
            Creates (Saves) a new instance to the database and flushes the session.
            </summary>
      <param name="instance">The ActiveRecord instance to be created on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Update(System.Object)">
      <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.UpdateAndFlush(System.Object)">
      <summary>
            Persists the modification on the instance
            state to the database and flushes the session.
            </summary>
      <param name="instance">The ActiveRecord instance to be updated on the database</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Delete(System.Object)">
      <summary>
            Deletes the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAndFlush(System.Object)">
      <summary>
            Deletes the instance from the database and flushes the session.
            </summary>
      <param name="instance">The ActiveRecord instance to be deleted</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Refresh(System.Object)">
      <summary>
            Refresh the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be reloaded</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.GetSessionFactoryHolder">
      <summary>
            Testing hock only.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Replicate(System.Object,NHibernate.ReplicationMode)">
      <summary>
            From NHibernate documentation: 
            Persist all reachable transient objects, reusing the current identifier 
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
      <param name="instance">The instance.</param>
      <param name="replicationMode">The replication mode.</param>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordMediator`1">
      <summary>
            Allow programmers to use the 
            ActiveRecord functionality without extending <see cref="T:Castle.ActiveRecord.ActiveRecordBase" /></summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Execute(Castle.ActiveRecord.NHibernateDelegate,`0)">
      <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
      <param name="call">The delegate instance</param>
      <param name="instance">The ActiveRecord instance</param>
      <returns>Whatever is returned by the delegate invocation</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindByPrimaryKey(System.Object,System.Boolean)">
      <summary>
            Finds an object instance by its primary key.
            </summary>
      <param name="id">ID value</param>
      <param name="throwOnNotFound">
        <c>true</c> if you want an exception to be thrown
            if the object is not found</param>
      <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindByPrimaryKey(System.Object)">
      <summary>
            Finds an object instance by its primary key.
            </summary>
      <param name="id">ID value</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="orders">The sort order - used to determine which record is the first one</param>
      <param name="criterias">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="criterias">The criteria expression</param>
      <returns>A <c>targetType</c> instance or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindOne(NHibernate.Expression.ICriterion[])">
      <summary>
            Searches and returns the first row.
            </summary>
      <param name="criterias">The criterias.</param>
      <returns>A instance the targetType or <c>null</c></returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll">
      <summary>
            Returns all instances found for the specified type.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
      <summary>
            Returns a portion of the query results (sliced)
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
      <param name="orders">
      </param>
      <param name="criterias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.Expression.ICriterion[])">
      <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
      <param name="criterias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.DeleteAll">
      <summary>
            Deletes all entities of <typeparamref name="T" />.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.DeleteAll(System.String)">
      <summary>
            Deletes all entities of <typeparamref name="T" /> that match the HQL where clause.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Save(`0)">
      <summary>
            Saves the instance to the database
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Create(`0)">
      <summary>
            Creates (Saves) a new instance to the database.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Update(`0)">
      <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Delete(`0)">
      <summary>
            Deletes the instance from the database.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Refresh(`0)">
      <summary>
            Refresh the instance from the database.
            </summary>
      <param name="instance">The ActiveRecord instance to be reloaded</param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.ExecuteQuery2``1(Castle.ActiveRecord.IActiveRecordQuery{``0})">
      <summary>
            Executes the query and return a strongly typed result
            </summary>
      <param name="query">The query.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists``1(``0)">
      <summary>
            Check if the <paramref name="id" /> exists in the database.
            </summary>
      <typeparam name="PkType">The <c>System.Type</c> of the PrimaryKey</typeparam>
      <param name="id">The id to check on</param>
      <returns>
        <c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Count">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Count(NHibernate.Expression.ICriterion[])">
      <summary>
            Returns the number of records of the specified 
            type in the database that match the given critera
            </summary>
      <param name="criteria">The criteria expression</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Count(System.String,System.Object[])">
      <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>The count result</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists">
      <summary>
            Check if there is any records in the db for the target type
            </summary>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists(System.String,System.Object[])">
      <summary>
            Check if there is any records in the db for the target type
            </summary>
      <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
      <param name="args">Positional parameters for the filter string</param>
      <returns>
        <c>true</c> if there's at least one row</returns>
    </member>
    <member name="T:Castle.ActiveRecord.SessionFactoryHolderDelegate">
      <summary>
            Delegate for use in <see cref="E:Castle.ActiveRecord.ActiveRecordStarter.SessionFactoryHolderCreated" /></summary>
      <param name="holder">
      </param>
    </member>
    <member name="T:Castle.ActiveRecord.ModelsCreatedDelegate">
      <summary>
            Delegate for use in <see cref="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsCreated" /></summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordStarter">
      <summary>
            Performs the framework initialization.
            </summary>
      <remarks>
            This class is not thread safe.
            </remarks>
    </member>
    <member name="F:Castle.ActiveRecord.ActiveRecordStarter.configSource">
      <summary>
            This is saved so one can invoke <c>RegisterTypes</c> later
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(Castle.ActiveRecord.Framework.IConfigurationSource,System.Type[])">
      <summary>
            Initialize the mappings using the configuration and 
            the list of types
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly,Castle.ActiveRecord.Framework.IConfigurationSource)">
      <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified <c>Assembly</c></summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly[],Castle.ActiveRecord.Framework.IConfigurationSource)">
      <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified Assemblies
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize">
      <summary>
            Initializes the framework reading the configuration from
            the <c>AppDomain</c> and checking all the types on the executing <c>Assembly</c></summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.RegisterTypes(System.Type[])">
      <summary>
            Registers new types in ActiveRecord
            Usefull for dynamic type-adding after initialization
            </summary>
      <param name="types">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchema">
      <summary>
            Generates and executes the creation scripts for the database.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String)">
      <summary>
            Executes the specified script to create/drop/change the database schema
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String,System.Data.IDbConnection)">
      <summary>
            Executes the specified script to create/drop/change the database schema
            against the specified database connection
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.DropSchema">
      <summary>
            Generates and executes the Drop scripts for the database.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateDropScripts(System.String)">
      <summary>
            Generates and executes the drop scripts for the database.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateCreationScripts(System.String)">
      <summary>
            Generates the creation scripts for the database
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.ResetInitializationFlag">
      <summary>
            Intended to be used only by test cases
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.IsActiveRecordType(System.Type)">
      <summary>
            Return true if the type has a [ActiveRecord] attribute
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CollectValidActiveRecordTypesFromAssembly(System.Reflection.Assembly,System.Collections.ArrayList,Castle.ActiveRecord.Framework.IConfigurationSource)">
      <summary>
            Retrive all classies decorated with ActiveRecordAttribute or have been configured
            as a AR base class.
            </summary>
      <param name="assembly">Assembly to retrive types from</param>
      <param name="list">Array to store retrived types in</param>
      <param name="source">IConfigurationSource to inspect AR base declerations from</param>
    </member>
    <member name="E:Castle.ActiveRecord.ActiveRecordStarter.SessionFactoryHolderCreated">
      <summary>
            So others frameworks can intercept the 
            creation and act on the holder instance
            </summary>
    </member>
    <member name="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsCreated">
      <summary>
            Allows other frameworks to modify the ActiveRecordModel
            before the generation of the NHibernate XML configuration.
            As an example, this may be used to rewrite table names to
            conform to an application-specific standard.  Since the
            configuration source is passed in, it is possible to
            determine the underlying database type and make changes
            if necessary.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordValidationBase">
      <summary>
            Extends <see cref="T:Castle.ActiveRecord.ActiveRecordBase" /> adding automatic validation support.
            <seealso cref="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid" /></summary>
      <example>
        <code>
            public class Customer : ActiveRecordBase
            {
            	...
            	
            	[Property, ValidateNotEmpty]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            	
            	[Property, ValidateNotEmpty, ValidateEmail]
            	public int Email
            	{
            		get { return _email; }
            		set { _email = value; }
            	}
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase.__validators">
      <summary>
            List of validators that should be executed for this class
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase._errorMessages">
      <summary>
            List of error messages
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.#ctor">
      <summary>
            Constructs an ActiveRecordValidationBase
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.CollectValidators">
      <summary>
            Collect the validations applied to this class properties.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid">
      <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.OnNotValid">
      <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
      <remarks>
            You can override this method to declare a better behavior.
            </remarks>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.ValidationErrorMessages">
      <summary>
            Returns a list of current validation errors messages.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.PropertiesValidationErrorMessage">
      <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.ActiveRecordValidationBase`1">
      <summary>
            Extends <see cref="T:Castle.ActiveRecord.ActiveRecordBase" /> adding automatic validation support.
            <seealso cref="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid" /></summary>
      <example>
        <code>
            public class Customer : ActiveRecordBase
            {
            	...
            	
            	[Property, ValidateNotEmpty]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            	
            	[Property, ValidateNotEmpty, ValidateEmail]
            	public int Email
            	{
            		get { return _email; }
            		set { _email = value; }
            	}
            </code>
      </example>
    </member>
    <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase`1.__validators">
      <summary>
            List of validators that should be executed for this class
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase`1._errorMessages">
      <summary>
            List of error messages
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.#ctor">
      <summary>
            Constructs an ActiveRecordValidationBase
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.CollectValidators(System.Type)">
      <summary>
            Collect the validations applied to this class properties.
            </summary>
      <param name="targetType">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.IsValid">
      <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.OnNotValid">
      <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
      <remarks>
            You can override this method to declare a better behavior.
            </remarks>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ValidationErrorMessages">
      <summary>
            Returns a list of current validation errors messages.
            </summary>
    </member>
    <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.PropertiesValidationErrorMessage">
      <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator">
      <summary>
            Used to execute a script file to create/update/drop 
            a database schema. Inspired on NHibernate SchemaExport class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.#ctor(NHibernate.Cfg.Configuration)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator" /> class.
            </summary>
      <param name="config">The config.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.Execute(System.String)">
      <summary>
            Executes the specified script file.
            </summary>
      <param name="scriptFileName">Name of the script file.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.ExecuteScriptParts(System.Data.IDbConnection,System.String[])">
      <summary>
            Executes the script parts.
            </summary>
      <param name="connection">The connection.</param>
      <param name="parts">The parts.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.OpenFileAndStripContents(System.String)">
      <summary>
            Opens the file and return an array of seperate commands that it contains
            </summary>
      <param name="scriptFileName">Name of the script file.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.CriteriaHelper.AddCriterionToCriteria(NHibernate.ICriteria,NHibernate.Expression.ICriterion[])">
      <summary>
            Adds a collection of ICriterion to an ICriteria.
            </summary>
      <param name="criteria">The ICriteria that will be modified.</param>
      <param name="criterions">The collection of Criterion.</param>
    </member>
    <member name="M:Castle.ActiveRecord.CriteriaHelper.AddOrdersToCriteria(NHibernate.ICriteria,NHibernate.Expression.Order[])">
      <summary>
            Adds a collection of Order (sort by) specifiers to an ICriteria.
            </summary>
      <param name="criteria">The ICriteria that will be modified.</param>
      <param name="orders">The collection of Order specifiers.</param>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.DictionaryAdapter">
      <summary>
            Maps keys to position in the values array. 
            Basically key -&gt; index
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry">
      <summary>
            Simple link list entry
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry.#ctor(System.String,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry" /> class.
            </summary>
      <param name="key">The key.</param>
      <param name="index">The index.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry.Find(System.String)">
      <summary>
            Finds the specified key.
            </summary>
      <param name="key">The key.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.#ctor(System.String[],System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.DictionaryAdapter" /> class.
            </summary>
      <param name="names">The names.</param>
      <param name="values">The values.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The <see cref="T:System.Object"></see> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object"></see> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"></see> object. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Clear">
      <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only. </exception>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
      <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
      <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size; otherwise, false.</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.HookDispatcher">
      <summary>
            Translates the <c>IInterceptor</c>
            messages to instance possible hooks
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.HookDispatcher" /> class.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called just before an object is initialized
            </summary>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="propertyNames">
      </param>
      <param name="state">
      </param>
      <param name="types">
      </param>
      <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
      <returns>
        <c>true</c> if the user modified the <c>state</c> in any way</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
      <param name="currentState">
      </param>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="previousState">
      </param>
      <param name="propertyNames">
      </param>
      <param name="types">
      </param>
      <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
      <returns>
        <c>true</c> if the user modified the <c>currentState</c> in any way</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called before an object is saved
            </summary>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="propertyNames">
      </param>
      <param name="state">
      </param>
      <param name="types">
      </param>
      <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
      <returns>
        <c>true</c> if the user modified the <c>state</c> in any way</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called before an object is deleted
            </summary>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="propertyNames">
      </param>
      <param name="state">
      </param>
      <param name="types">
      </param>
      <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PreFlush(System.Collections.ICollection)">
      <summary>
            Called before a flush
            </summary>
      <param name="entities">The entities</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PostFlush(System.Collections.ICollection)">
      <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
      <param name="entities">The entitites</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.IsUnsaved(System.Object)">
      <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
      <remarks>
            The return value determines if the object is saved
            <list><item><c>true</c> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item><item><c>false</c> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item><item><c>null</c> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item></list></remarks>
      <param name="entity">A transient entity</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
      <remarks>
        <list>
          <item>an array of property indicies - the entity is dirty</item>
          <item>an empty array - the entity is not dirty</item>
          <item>
            <c>null</c> - use Hibernate's default dirty-checking algorithm</item>
        </list>
      </remarks>
      <param name="entity">A persistent entity</param>
      <param name="currentState">
      </param>
      <param name="id">
      </param>
      <param name="previousState">
      </param>
      <param name="propertyNames">
      </param>
      <param name="types">
      </param>
      <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.Instantiate(System.Type,System.Object)">
      <summary>
            Instantiate the entity class. Return <c>null</c> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
      <param name="type">A mapped type</param>
      <param name="id">The identifier of the new instance</param>
      <returns>An instance of the class, or <c>null</c> to choose default behaviour</returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.HookDispatcher.Instance">
      <summary>
            Gets the sole instance.
            </summary>
      <value>The instance.</value>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.InterceptorFactory">
      <summary>
            Create an interceptor for the session.
            Allow to override the default for creating the intercetor
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.InterceptorFactory.CreateInterceptor">
      <summary>
            Creates an instance of the interceptor
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.InterceptorFactory.Create">
      <summary>
            Create the 
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.RootTypeHandler">
      <summary>
            Type of delegate that is called when a root type is registered.
            </summary>
      <param name="sender">
      </param>
      <param name="rootType">
      </param>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder">
      <summary>
            Keeps an association of SessionFactories to a object model 
            tree;
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.Register(System.Type,NHibernate.Cfg.Configuration)">
      <summary>
            Associates a Configuration object to a root type
            </summary>
      <param name="rootType">
      </param>
      <param name="cfg">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetAllConfigurations">
      <summary>
            Pendent
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetConfiguration(System.Type)">
      <summary>
            Requests the Configuration associated to the type.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetSessionFactory(System.Type)">
      <summary>
            Obtains the SessionFactory associated to the type.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.CreateSession(System.Type)">
      <summary>
            Creates a session for the associated type
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ReleaseSession(NHibernate.ISession)">
      <summary>
            Releases the specified session
            </summary>
      <param name="session">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetRootType(System.Type)">
      <summary>
            Gets the type of the root.
            </summary>
      <param name="type">The type.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ThreadScopeInfo">
      <summary>
            Gets or sets the implementation of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /></summary>
    </member>
    <member name="E:Castle.ActiveRecord.Framework.ISessionFactoryHolder.OnRootTypeRegistered">
      <summary>
            Raised when a new root type is registered. 
            A new root type creates a new <c>ISessionFactory</c></summary>
    </member>
    <member name="T:Castle.ActiveRecord.NotFoundException">
      <summary>
            This exception is thrown when loading an entity by its PK failed because the entity did not exist.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.NotFoundException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.NotFoundException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.ActiveRecord.NotFoundException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.NotFoundException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.ActiveRecord.NotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.NotFoundException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
      <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.SessionFactoryHolder">
      <summary>
            Default implementation of <seealso cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder" /></summary>
      <remarks>
            This class is thread safe
            </remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.Register(System.Type,NHibernate.Cfg.Configuration)">
      <summary>
            Associates a Configuration object to a root type
            </summary>
      <param name="rootType">
      </param>
      <param name="cfg">
      </param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetConfiguration(System.Type)">
      <summary>
            Requests the Configuration associated to the type.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetAllConfigurations">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetSessionFactory(System.Type)">
      <summary>
            Optimized with reader/writer lock.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.CreateSession(System.Type)">
      <summary>
            Creates a session for the associated type
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetRootType(System.Type)">
      <summary>
            Gets the type of the root.
            </summary>
      <param name="type">The type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.ReleaseSession(NHibernate.ISession)">
      <summary>
            Releases the specified session
            </summary>
      <param name="session">
      </param>
    </member>
    <member name="P:Castle.ActiveRecord.Framework.SessionFactoryHolder.ThreadScopeInfo">
      <summary>
            Gets or sets the implementation of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo" /></summary>
      <value>
      </value>
    </member>
    <member name="E:Castle.ActiveRecord.Framework.SessionFactoryHolder.OnRootTypeRegistered">
      <summary>
            Raised when a root type is registered.
            </summary>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.SessionScopeWebModule">
      <summary>
            HttpModule to set up a session for the request lifetime.
            <seealso cref="T:Castle.ActiveRecord.SessionScope" /></summary>
      <remarks>
            To install the module, you must:
            <para><list type="number"><item><description>
                   Add the module to the <c>httpModules</c> configuration section within <c>system.web</c></description></item></list></para></remarks>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.SessionScopeWebModule.SessionKey">
      <summary>
            The key used to store the session in the context items
            </summary>
    </member>
    <member name="F:Castle.ActiveRecord.Framework.SessionScopeWebModule.isWebConfigured">
      <summary>
            Used to check whether the ThreadScopeInfo being used is suitable for a web environment
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.Init(System.Web.HttpApplication)">
      <summary>
            Initialize the module.
            </summary>
      <param name="app">The app.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.Dispose">
      <summary>
            Disposes of the resources (other than memory) used by the module that implements <see cref="T:System.Web.IHttpModule"></see>.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.OnBeginRequest(System.Object,System.EventArgs)">
      <summary>
            Called when request is started, create a session for the request
            </summary>
      <param name="sender">The sender.</param>
      <param name="e">The <see cref="T:System.EventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.OnEndRequest(System.Object,System.EventArgs)">
      <summary>
            Called when the request ends, dipose of the scope
            </summary>
      <param name="sender">The sender.</param>
      <param name="e">The <see cref="T:System.EventArgs" /> instance containing the event data.</param>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.SupportingUtils">
      <summary>
            Contains utility methods for dealing with ActiveRecord objects
            and collections.
            Useful for external frameworks.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.FindAll(System.Type)">
      <summary>
            Obsolete method, use ActiveRecordMediator or ActiveRecordMediator{T} instead
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.FindByPK(System.Type,System.Object)">
      <summary>
            Obsolete method, use ActiveRecordMediator or ActiveRecordMediator{T} instead
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.FindByPK(System.Type,System.Object,System.Boolean)">
      <summary>
            Obsolete method, use ActiveRecordMediator or ActiveRecordMediator{T} instead
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IList)">
      <summary>
            Create an array from an IList.
            </summary>
      <param name="targetType">Type of the item in the array.</param>
      <param name="list">The list.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IEnumerable,System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable" /> to an
            strongly-typed array.
            </summary>
      <param name="type">The type of the new array</param>
      <param name="list">The source list</param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IEnumerable,System.Int32,System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable" /> to an
            strongly-typed array.
            </summary>
      <param name="type">The type of the new array</param>
      <param name="list">The source list</param>
      <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildObjectArray(System.Type,System.Collections.IEnumerable,System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable" /> to an
            strongly-typed array.
            </summary>
      <param name="type">
            The class of the object which will be created for each row contained in
            the supplied <paramref name="list" />.
            </param>
      <param name="list">The source list</param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
      <remarks>A good alternative is to use the new <see cref="T:Castle.ActiveRecord.ImportAttribute" /></remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildObjectArray``1(System.Collections.IEnumerable,System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable" /> to an
            strongly-typed array.
            </summary>
      <typeparam name="T">The type of the new array</typeparam>
      <param name="list">The source list</param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray``1(System.Collections.IEnumerable,System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable" /> to a
            strongly-typed array.
            </summary>
      <param name="list">The source list</param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
      <typeparam name="T">
            The class of the object which will be created for each row contained in
            the supplied <paramref name="list" />.
            </typeparam>
      <remarks>A good alternative is to use the new <see cref="T:Castle.ActiveRecord.ImportAttribute" /></remarks>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray``1(System.Collections.IEnumerable,System.Nullable{System.Int32},System.Boolean)">
      <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable" /> to an
            strongly-typed array.
            </summary>
      <typeparam name="T">The type of the new array</typeparam>
      <param name="list">The source list</param>
      <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
      <param name="distinct">If true, only distinct results will be inserted in the array</param>
      <returns>The strongly-typed array</returns>
    </member>
    <member name="T:Castle.ActiveRecord.Framework.TransactionException">
      <summary>
            This exception is thrown by TransactionScope.
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.TransactionException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.TransactionException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.TransactionException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.TransactionException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.ActiveRecord.Framework.TransactionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.TransactionException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
      <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
    </member>
    <member name="T:Castle.ActiveRecord.ValidationException">
      <summary>
            This exception is raised when a validation error occurs
            </summary>
    </member>
    <member name="M:Castle.ActiveRecord.ValidationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidationException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidationException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidationException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
      <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
    </member>
    <member name="M:Castle.ActiveRecord.ValidationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> with information about the exception.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The info parameter is a null reference (Nothing in Visual Basic). </exception>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter" />
      </PermissionSet>
    </member>
    <member name="M:Castle.ActiveRecord.ValidationException.#ctor(System.String,System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidationException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="errorMessages">The error messages.</param>
    </member>
    <member name="M:Castle.ActiveRecord.ValidationException.#ctor(System.String,System.Exception,System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidationException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
      <param name="errorMessages">The error messages.</param>
    </member>
    <member name="P:Castle.ActiveRecord.ValidationException.ValidationErrorMessages">
      <summary>
            Returns a list of current validation errors messages, if available.
            </summary>
    </member>
    <member name="T:Castle.Core.LifestyleAttribute">
      <summary>
            Base for Attributes that want to express lifestyle
            chosen by the component.
            </summary>
    </member>
    <member name="M:Castle.Core.LifestyleAttribute.#ctor(Castle.Core.LifestyleType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifestyleAttribute" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="P:Castle.Core.LifestyleAttribute.Lifestyle">
      <summary>
            Gets or sets the lifestyle.
            </summary>
      <value>The lifestyle.</value>
    </member>
    <member name="T:Castle.Core.CastleComponentAttribute">
      <summary>
            This attribute is usefull only when you want to register all components
            on an assembly as a batch process. 
            By doing so, the batch register will look 
            for this attribute to distinguish components from other classes.
            </summary>
    </member>
    <member name="T:Castle.Core.ComponentActivatorAttribute">
      <summary>
            Associates a custom component with a component
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentActivatorAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentActivatorAttribute" /> class.
            </summary>
      <param name="componentActivatorType">Type of the component activator.</param>
    </member>
    <member name="P:Castle.Core.ComponentActivatorAttribute.ComponentActivatorType">
      <summary>
            Gets the type of the component activator.
            </summary>
      <value>The type of the component activator.</value>
    </member>
    <member name="T:Castle.Core.ComponentProxyBehaviorAttribute">
      <summary>
            Specifies the proxying behavior for a component.
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentProxyBehaviorAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" /> class.
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseSingleInterfaceProxy">
      <summary>
            Determines if the component requires a single interface proxy.
            </summary>
      <value>
        <c>true</c> if the component requires a single interface proxy.</value>
    </member>
    <member name="T:Castle.Core.DoNotWireAttribute">
      <summary>
            Marks as property to be skipped and not be wired
            by the IoC container
            </summary>
    </member>
    <member name="T:Castle.Core.InterceptorAttribute">
      <summary>
            Used to declare that a component wants interceptors acting on it.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.String)">
      <summary>
            Constructs the InterceptorAttribute pointing to
            a key to a interceptor
            </summary>
      <param name="componentKey">
      </param>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.Type)">
      <summary>
            Constructs the InterceptorAttribute pointing to
            a service
            </summary>
      <param name="interceptorType">
      </param>
    </member>
    <member name="T:Castle.Core.SingletonAttribute">
      <summary>
            Indicates that the target components wants a
            singleton lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.SingletonAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.SingletonAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.TransientAttribute">
      <summary>
            Indicates that the target components wants a
            transient lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.TransientAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.TransientAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.PerThreadAttribute">
      <summary>
            Indicates that the target components wants a
            per thread lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PerThreadAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.PerWebRequestAttribute">
      <summary>
            Indicates that the target components wants a
            per web request lifestyle.
            </summary>
    </member>
    <member name="T:Castle.Core.PooledAttribute">
      <summary>
            Indicates that the target components wants a
            pooled lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class
            using the default initial pool size (5) and the max pool size (15).
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class.
            </summary>
      <param name="initialPoolSize">Initial size of the pool.</param>
      <param name="maxPoolSize">Max pool size.</param>
    </member>
    <member name="P:Castle.Core.PooledAttribute.InitialPoolSize">
      <summary>
            Gets the initial size of the pool.
            </summary>
      <value>The initial size of the pool.</value>
    </member>
    <member name="P:Castle.Core.PooledAttribute.MaxPoolSize">
      <summary>
            Gets the maximum pool size.
            </summary>
      <value>The size of the max pool.</value>
    </member>
    <member name="T:Castle.Core.CustomLifestyleAttribute">
      <summary>
            Indicates that the target components wants a
            custom lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.CustomLifestyleAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CustomLifestyleAttribute" /> class.
            </summary>
      <param name="lifestyleHandler">The lifestyle handler.</param>
    </member>
    <member name="P:Castle.Core.CustomLifestyleAttribute.LifestyleHandlerType">
      <summary>
            Gets the type of the lifestyle handler.
            </summary>
      <value>The type of the lifestyle handler.</value>
    </member>
    <member name="T:Castle.Core.Interceptor.IInterceptor">
      <summary>
            New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IInvocation">
      <summary>
            New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethod">
      <summary>
            Returns the concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />, with any generic parameters bound to real types.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />, or <see cref="P:Castle.Core.Interceptor.IInvocation.Method" /> if not a generic method.</returns>
      <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />.</remarks>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethodInvocationTarget">
      <summary>
            Returns the concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />, with any generic parameters bound to real types.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />, or <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
      <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />.</remarks>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.GenericArguments">
      <summary>
            The generic arguments of the method, or null if not a generic method.
            </summary>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget">
      <summary>
            For interface proxies, this will point to the
            <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IOnBehalfAware">
      <summary>
            Interceptors might implement this to receive the
            ComponentModel on behalf of the component where the
            interceptor is acting.
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IProxyTargetAccessor">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.DynProxyGetTarget">
      <summary>
            Get the proxy target (note that null is a valid target!)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.GetInterceptors">
      <summary>
            Gets the interceptors for the proxy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.IVertex">
      <summary>
            Abstract representation of a vertex.
            </summary>
    </member>
    <member name="P:Castle.Core.GraphNode.Dependers">
      <summary>
            The nodes that dependes on this node
            </summary>
    </member>
    <member name="P:Castle.Core.GraphNode.Dependents">
      <summary>
            The nodes that this node depends
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.White">
      <summary>
            The node has not been visited yet
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Gray">
      <summary>
            This node is in the process of being visited
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Black">
      <summary>
            This now was visited
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.ColorsSet">
      <summary>
            Represents a collection of objects
            which are guaranted to be unique 
            and holds a color for them
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.TimestampSet">
      <summary>
            Holds a timestamp (integer) 
            for a given item
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.LinkedList.GetNode(System.Int32)">
      <summary>
            Returns the node at the specified index.
            </summary>
      <param name="index">The lookup index.</param>
      <returns>The node at the specified index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If the specified <paramref name="index" /> is greater than the
            number of objects within the list.
            </exception>
    </member>
    <member name="M:Castle.Core.Internal.LinkedList.ValidateIndex(System.Int32)">
      <summary>
            Validates the specified index.
            </summary>
      <param name="index">The lookup index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If the index is invalid.
            </exception>
    </member>
    <member name="T:Castle.Core.IInitializable">
      <summary>
            Lifecycle interface. If implemented by a component,
            the method Initialized will be invoked by the container
            before making the component available to the external world.
            </summary>
    </member>
    <member name="M:Castle.Core.IInitializable.Initialize">
      <summary>
            Implementors should perform any initialization logic.
            </summary>
    </member>
    <member name="T:Castle.Core.IRecyclable">
      <summary>
            Only called for components that 
            belongs to a pool when the component
            comes back to the pool.
            </summary>
    </member>
    <member name="M:Castle.Core.IRecyclable.Recycle">
      <summary>
            Implementors should perform any 
            initialization/clean up.
            </summary>
    </member>
    <member name="T:Castle.Core.IStartable">
      <summary>
            Interface for components that wish to be started by the container
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Start">
      <summary>
            Starts this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Stop">
      <summary>
            Stops this instance.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILoggerFactory">
      <summary>
            Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger" />s.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
      <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
      <summary>
            Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
      <summary>
            Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger" /> or
            <see cref="T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
      <summary>
            Gets the configuration file.
            </summary>
      <param name="filename">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
      <summary>
            Gets the configuration file.
            </summary>
      <param name="filename">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleFactory">
      <summary>
            Summary description for ConsoleFactory.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogFactory">
      <summary>
            NullLogFactory used when logging is turned off.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
      <summary>
            Creates an instance of ILogger with the specified name.
            </summary>
      <param name="name">Name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
      <param name="name">Name.</param>
      <param name="level">Level.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.StreamLoggerFactory">
      <summary>
            Creates <see cref="T:Castle.Core.Logging.StreamLogger" /> outputing 
            to files. The name of the file is derived from the log name
            plus the 'log' extension.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILogger">
      <summary>
            Manages logging.
            </summary>
      <remarks>
            This is a facade for the different logging subsystems.
            It offers a simplified interface that follows IOC patterns
            and a simplified priority/level/severity abstraction. 
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
      <summary>
            Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
      <summary>
            Logs a debug message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
      <summary>
            Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
      <summary>
            Logs an info message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
      <summary>
            Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
      <summary>
            Logs a warn message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
      <summary>
            Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Exception)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Object[])">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
      <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="name">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
      <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
      <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
      <value>True if "debug" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
      <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
      <value>True if "info" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
      <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
      <value>True if "warn" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
      <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
      <value>True if "error" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>True if "fatal" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalErrorEnabled">
      <summary>
            Determines if messages of priority "fatalError" will be logged.
            </summary>
      <value>True if "fatalError" messages will be logged.</value>
    </member>
    <member name="T:Castle.Core.Logging.LevelFilteredLogger">
      <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
      <summary>
            Creates a new <c>LevelFilteredLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
      <summary>
            Keep the instance alive in a remoting scenario
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
      <summary>
            Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
      <summary>
            Logs a debug message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
      <summary>
            Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
      <summary>
            Logs an info message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
      <summary>
            Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
      <summary>
            Logs a warn message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
      <summary>
            Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Exception)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Object[])">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            Implementors output the log content by implementing this method only.
            Note that exception can be null
            </summary>
      <param name="level">
      </param>
      <param name="name">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
      <value>
            The <c>LoggerLevel</c> that this logger
            will be using. Defaults to <c>LoggerLevel.Off</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
      <value>
            The name that this logger will be using. 
            Defaults to <c>String.Empty</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
      <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
      <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
      <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
      <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalErrorEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleLogger">
      <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
      <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new ConsoleLogger with the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
      <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c>.
            </summary>
      <param name="name">The logs Name.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new ConsoleLogger.
            </summary>
      <param name="name">The logs Name.</param>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            A Common method to log.
            </summary>
      <param name="level">The level of logging</param>
      <param name="name">The name of the logger</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
      <summary>
            Returns a new <c>ConsoleLogger</c> with the name
            added after this loggers name, with a dot in between.
            </summary>
      <param name="newName">The added hierarchical name.</param>
      <returns>A new <c>ConsoleLogger</c>.</returns>
    </member>
    <member name="T:Castle.Core.Logging.DiagnosticsLogger">
      <summary>
            The Logger using standart Diagnostics namespace.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="machineName">
        <see cref="P:System.Diagnostics.EventLog.MachineName" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLogger">
      <summary>
            Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger" /> and
            allows the storage and retrieval of Contexts. These are supported in
            both log4net and NLog.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
      <summary>
            Exposes the Global Context of the extended logger. 
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
      <summary>
            Exposes the Thread Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
      <summary>
            Exposes the Thread Stack of the extended logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogger">
      <summary>
            The Null Logger class.  This is useful for implementations where you need
            to provide a logger to a utility class, but do not want any output from it.
            It also helps when you have a utility that does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.#ctor">
      <summary>
            Creates a new <c>NullLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Exception)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
      <param name="exception">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
      <summary>
            Returns this <c>NullLogger</c>.
            </summary>
      <param name="name">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalErrorEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
      <summary>
            Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
      <summary>
            Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
      <summary>
            Returns empty context stacks.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IContextProperties">
      <summary>
            Interface for Context Properties implementations
            </summary>
      <remarks>
        <para>
            This interface defines a basic property get set accessor.
            </para>
        <para>
            Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
            </para>
      </remarks>
    </member>
    <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Gets or sets the value of a property
            </para>
      </remarks>
    </member>
    <member name="T:Castle.Core.Logging.StreamLogger">
      <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
      <remarks>
            This logger is not thread safe.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
      <summary>
            Creates a new <c>StreamLogger</c> with default encoding 
            and buffer size. Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
      <summary>
            Creates a new <c>StreamLogger</c> with default buffer size.
            Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
      <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>
            Creates a new <c>StreamLogger</c>. 
            Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
      <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
      <param name="bufferSize">
            The buffer size that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
      <summary>
            Creates a new <c>StreamLogger</c> with 
            Debug as default Level.
            </summary>
      <param name="name">The name of the log.</param>
      <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
    </member>
    <member name="T:Castle.Core.Logging.WebLogger">
      <summary>
            The WebLogger sends everything to the HttpContext.Trace 
            </summary>
      <remarks>
            Trace must be enabled on the Asp.Net configuration file (web.config or machine.config)
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor">
      <summary>
            Creates a new WebLogger with the priority set to DEBUG.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="logLevel">The Log level typecode.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(System.String)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="name">The Log name.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="name">The Log name.</param>
      <param name="logLevel">The Log level typecode.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            A Common method to log.
            </summary>
      <param name="level">The level of logging</param>
      <param name="name">The Log name.</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.CreateChildLogger(System.String)">
      <summary>
            Just returns this logger (<c>WebLogger</c> is not hierarchical).
            </summary>
      <param name="newName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="T:Castle.Core.Logging.LoggerLevel">
      <summary>
            Supporting Logger levels.
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Off">
      <summary>
            Logging will be off
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
      <summary>
            Fatal logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Error">
      <summary>
            Error logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
      <summary>
            Warn logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Info">
      <summary>
            Info logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
      <summary>
            Debug logging level
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.IConfiguration">
      <summary>
            Summary description for IConfiguration.
            </summary>
      <summary>
        <see cref="T:Castle.Core.Configuration.IConfiguration" /> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Name">
      <summary>
            Gets the name of the node.
            </summary>
      <value>
            The Name of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Value">
      <summary>
            Gets the value of the node.
            </summary>
      <value>
            The Value of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Children">
      <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of <see cref="T:Castle.Core.Configuration.IConfiguration" />
            elements containing all node children.
            </summary>
      <value>The Collection of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
      <summary>
            Gets an <see cref="T:System.Collections.IDictionary" /> of the configuration attributes.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.AbstractConfiguration">
      <summary>
            This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration" /> implementation
            that deals with methods that can be abstracted away
            from underlying implementations.
            </summary>
      <remarks>
        <para>
          <b>AbstractConfiguration</b> makes easier to implementers 
            to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration" /></para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
      <summary>
            Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
      <summary>
            Gets all child nodes.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
      <summary>
            Gets node attributes.
            </summary>
      <value>
            All attributes of the node.
            </value>
    </member>
    <member name="T:Castle.Core.Configuration.ConfigurationCollection">
      <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration" /> objects.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(Castle.Core.Configuration.ConfigurationCollection)">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(Castle.Core.Configuration.IConfiguration[])">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.Add(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds an <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.IConfiguration" /> to add.</param>
      <returns>
            The index at which the new element was inserted.
            </returns>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.AddRange(Castle.Core.Configuration.IConfiguration[])">
      <summary>
            Adds an array of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <param name="value">The Array of <see cref="T:Castle.Core.Configuration.IConfiguration" /> to add.</param>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.AddRange(Castle.Core.Configuration.ConfigurationCollection)">
      <summary>
            Adds a <see cref="T:Castle.Core.Configuration.ConfigurationCollection" />.
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> to add.</param>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.CopyTo(Castle.Core.Configuration.IConfiguration[],System.Int32)">
      <summary>
            Copies the elements to a one-dimensional <see cref="T:System.Array" /> instance at the specified index.
            </summary>
      <param name="array">
            The one-dimensional <see cref="T:System.Array" /> must have zero-based indexing.
            </param>
      <param name="index">The zero-based index in array at which copying begins.</param>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.Contains(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Gets a value indicating whether the <see cref="T:Castle.Core.Configuration.IConfiguration" /> contains
            in the collection.
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.IConfiguration" /> to locate.</param>
      <returns>
        <see langword="true" /> if the <see cref="T:Castle.Core.Configuration.IConfiguration" /> is contained in the collection; 
            otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.Remove(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Removes a specific <see cref="T:Castle.Core.Configuration.IConfiguration" /> from the 
            collection.   
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.IConfiguration" /> to remove from the collection.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> is not found in the collection.
            </exception>
    </member>
    <member name="P:Castle.Core.Configuration.ConfigurationCollection.Item(System.Int32)">
      <summary>
            Represents the entry at the specified index of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <param name="index">
            The zero-based index of the entry to locate in the collection.
            </param>
      <value>
            The entry at the specified index of the collection.
            </value>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is outside the valid range of indexes for the collection.
            </exception>
    </member>
    <member name="T:Castle.Core.Configuration.MutableConfiguration">
      <summary>
            Summary description for MutableConfiguration.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="T:Castle.Core.LifestyleType">
      <summary>
            Enumeration used to mark the component's lifestyle.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Undefined">
      <summary>
            No lifestyle specified.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Singleton">
      <summary>
            Singleton components are instantiated once, and shared
            between all clients.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Thread">
      <summary>
            Thread components have a unique instance per thread.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Transient">
      <summary>
            Transient components are created on demand.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Pooled">
      <summary>
            Optimization of transient components that keeps
            instance in a pool instead of always creating them.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Custom">
      <summary>
            Any other logic to create/release components.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.PerWebRequest">
      <summary>
            PerWebRequest components are created once per Http Request
            </summary>
    </member>
    <member name="T:Castle.Core.PropertiesInspectionBehavior">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.ComponentModel">
      <summary>
            Represents the collection of information and
            meta information collected about a component.
            </summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.name">
      <summary>Name (key) of the component</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.service">
      <summary>Service exposed</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.implementation">
      <summary>Implementation for the service</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.extended">
      <summary>Extended properties</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.lifestyleType">
      <summary>Lifestyle for the component</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.customLifestyle">
      <summary>Custom lifestyle, if any</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.customComponentActivator">
      <summary>Custom activator, if any</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.dependencies">
      <summary>Dependencies the kernel must resolve</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.constructors">
      <summary>All available constructors</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.properties">
      <summary>All potential properties that can be setted by the kernel</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.lifecycleSteps">
      <summary>Steps of lifecycle</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.parameters">
      <summary>External parameters</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.configuration">
      <summary>Configuration node associated</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.interceptors">
      <summary>Interceptors associated</summary>
    </member>
    <member name="M:Castle.Core.ComponentModel.#ctor(System.String,System.Type,System.Type)">
      <summary>
            Constructs a ComponentModel
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.Name">
      <summary>
            Sets or returns the component key
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.Service">
      <summary>
            Gets or sets the service exposed.
            </summary>
      <value>The service.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Implementation">
      <summary>
            Gets or sets the component implementation.
            </summary>
      <value>The implementation.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.RequiresGenericArguments">
      <summary>
            Gets or sets a value indicating whether the component requires generic arguments.
            </summary>
      <value>
        <c>true</c> if generic arguments are required; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.ExtendedProperties">
      <summary>
            Gets or sets the extended properties.
            </summary>
      <value>The extended properties.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Constructors">
      <summary>
            Gets the constructors candidates.
            </summary>
      <value>The constructors.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Properties">
      <summary>
            Gets the properties set.
            </summary>
      <value>The properties.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Configuration">
      <summary>
            Gets or sets the configuration.
            </summary>
      <value>The configuration.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.LifecycleSteps">
      <summary>
            Gets the lifecycle steps.
            </summary>
      <value>The lifecycle steps.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.LifestyleType">
      <summary>
            Gets or sets the lifestyle type.
            </summary>
      <value>The type of the lifestyle.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.InspectionBehavior">
      <summary>
            Gets or sets the strategy for
            inspecting public properties 
            on the components
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomLifestyle">
      <summary>
            Gets or sets the custom lifestyle.
            </summary>
      <value>The custom lifestyle.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomComponentActivator">
      <summary>
            Gets or sets the custom component activator.
            </summary>
      <value>The custom component activator.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Interceptors">
      <summary>
            Gets the interceptors.
            </summary>
      <value>The interceptors.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Parameters">
      <summary>
            Gets the parameter collection.
            </summary>
      <value>The parameters.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Dependencies">
      <summary>
            Dependencies are kept within constructors and
            properties. Others dependencies must be 
            registered here, so the kernel (as a matter 
            of fact the handler) can check them
            </summary>
    </member>
    <member name="T:Castle.Core.ConstructorCandidate">
      <summary>
            Represents a constructor of the component 
            that the container can use to initialize it properly.
            </summary>
    </member>
    <member name="M:Castle.Core.ConstructorCandidate.#ctor(System.Reflection.ConstructorInfo,Castle.Core.DependencyModel[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ConstructorCandidate" /> class.
            </summary>
      <param name="constructorInfo">The constructor info.</param>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Constructor">
      <summary>
            Gets the ConstructorInfo (from reflection).
            </summary>
      <value>The constructor.</value>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Dependencies">
      <summary>
            Gets the dependencies this constructor candidate exposes.
            </summary>
      <value>The dependencies.</value>
    </member>
    <member name="T:Castle.Core.ConstructorCandidateCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.ConstructorCandidate" /></summary>
    </member>
    <member name="M:Castle.Core.ConstructorCandidateCollection.Add(Castle.Core.ConstructorCandidate)">
      <summary>
            Adds the specified candidate.
            </summary>
      <param name="candidate">The candidate.</param>
    </member>
    <member name="M:Castle.Core.ConstructorCandidateCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="P:Castle.Core.ConstructorCandidateCollection.FewerArgumentsCandidate">
      <summary>
            Gets the fewer arguments candidate.
            </summary>
      <value>The fewer arguments candidate.</value>
    </member>
    <member name="T:Castle.Core.DependencyModel">
      <summary>
            Represents a dependency (other component or a 
            fixed value available through external configuration).
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModel.#ctor(Castle.Core.DependencyType,System.String,System.Type,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModel" /> class.
            </summary>
      <param name="type">The type.</param>
      <param name="dependencyKey">The dependency key.</param>
      <param name="targetType">Type of the target.</param>
      <param name="isOptional">if set to <c>true</c> [is optional].</param>
    </member>
    <member name="M:Castle.Core.DependencyModel.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Castle.Core.DependencyModel.GetHashCode">
      <summary>
            Serves as a hash function for a particular type, suitable
            for use in hashing algorithms and data structures like a hash table.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Castle.Core.DependencyModel.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
        <see langword="true" /> if the specified <see cref="T:System.Object" /> is equal to the
            current <see cref="T:System.Object" />; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="P:Castle.Core.DependencyModel.DependencyType">
      <summary>
            Gets or sets the type of the dependency.
            </summary>
      <value>The type of the dependency.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.DependencyKey">
      <summary>
            Gets or sets the dependency key.
            </summary>
      <value>The dependency key.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.TargetType">
      <summary>
            Gets the type of the target.
            </summary>
      <value>The type of the target.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.IsOptional">
      <summary>
            Gets or sets whether this dependency is optional.
            </summary>
      <value>
        <c>true</c> if this dependency is optional; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.DependencyModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.DependencyModel" />.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor(Castle.Core.DependencyModelCollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor(Castle.Core.DependencyModel[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Add(Castle.Core.DependencyModel)">
      <summary>
            Adds the specified model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Remove(Castle.Core.DependencyModel)">
      <summary>
            Removes the specified model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Contains(Castle.Core.DependencyModel)">
      <summary>
            Determines whether this collection contains the the specified model.
            </summary>
      <param name="model">The model.</param>
      <returns>
        <c>true</c> if the collection contains the specified model; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.Core.InterceptorReference">
      <summary>
            Represents an reference to a Interceptor component.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="componentKey">The component key.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="serviceType">Type of the service.</param>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ServiceType">
      <summary>
            Gets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ComponentKey">
      <summary>
            Gets the interceptor component key.
            </summary>
      <value>The component key.</value>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ReferenceType">
      <summary>
            Gets the type of the reference.
            </summary>
      <value>The type of the reference.</value>
    </member>
    <member name="T:Castle.Core.InterceptorReferenceCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.InterceptorReference" /></summary>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Add(Castle.Core.InterceptorReference)">
      <summary>
            Adds the specified interceptor.
            </summary>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddFirst(Castle.Core.InterceptorReference)">
      <summary>
            Adds the the specified interceptor as the first.
            </summary>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddLast(Castle.Core.InterceptorReference)">
      <summary>
            Adds the the specified interceptor as the last.
            </summary>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Insert(System.Int32,Castle.Core.InterceptorReference)">
      <summary>
            Inserts the specified interceptor at the specified index.
            </summary>
      <param name="index">The index.</param>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            When implemented by a class, copies the elements of
            the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="array" /> is multidimensional.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para>
        <para>-or-</para>
        <para>The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para>
      </exception>
      <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.HasInterceptors">
      <summary>
            Gets a value indicating whether this instance has interceptors.
            </summary>
      <value>
        <c>true</c> if this instance has interceptors; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.Count">
      <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.SyncRoot">
      <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.IsSynchronized">
      <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized
            (thread-safe).
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Core.LifecycleStepCollection">
      <summary>
            Represents a collection of ordered lifecycle steps.
            </summary>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifecycleStepCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetCommissionSteps">
      <summary>
            Returns all steps for the commission phase
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetDecommissionSteps">
      <summary>
            Returns all steps for the decommission phase
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.Add(Castle.Core.LifecycleStepType,System.Object)">
      <summary>
            Adds a step to the commission or decomission phases.
            </summary>
      <param name="type">
      </param>
      <param name="stepImplementation">
      </param>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of
            the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="array" /> is multidimensional.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para>
        <para>-or-</para>
        <para>The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para>
      </exception>
      <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.HasCommissionSteps">
      <summary>
            Gets a value indicating whether this instance has commission steps.
            </summary>
      <value>
        <c>true</c> if this instance has commission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.HasDecommissionSteps">
      <summary>
            Gets a value indicating whether this instance has decommission steps.
            </summary>
      <value>
        <c>true</c> if this instance has decommission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.Count">
      <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.SyncRoot">
      <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.IsSynchronized">
      <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized
            (thread-safe).
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Core.MethodMetaModel">
      <summary>
            Represents meta information associated with a method
            (not yet defined)
            </summary>
    </member>
    <member name="M:Castle.Core.MethodMetaModel.#ctor(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.MethodMetaModel" /> class.
            </summary>
      <param name="configNode">The config node.</param>
    </member>
    <member name="P:Castle.Core.MethodMetaModel.ConfigNode">
      <summary>
            Gets the config node.
            </summary>
      <value>The config node.</value>
    </member>
    <member name="T:Castle.Core.MethodMetaModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.MethodMetaModel" /></summary>
    </member>
    <member name="M:Castle.Core.MethodMetaModelCollection.Add(Castle.Core.MethodMetaModel)">
      <summary>
            Adds the specified model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="P:Castle.Core.MethodMetaModelCollection.MethodInfo2Model">
      <summary>
            Gets the method info2 model.
            </summary>
      <value>The method info2 model.</value>
    </member>
    <member name="T:Castle.Core.ParameterModel">
      <summary>
            Represents a parameter. Usually the parameter
            comes from the external world, ie, an external configuration.
            </summary>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="P:Castle.Core.ParameterModel.Name">
      <summary>
            Gets the name.
            </summary>
      <value>The name.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.Value">
      <summary>
            Gets the value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.ConfigValue">
      <summary>
            Gets the config value.
            </summary>
      <value>The config value.</value>
    </member>
    <member name="T:Castle.Core.ParameterModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.ParameterModel" /></summary>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModelCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,System.String)">
      <summary>
            Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="configNode">The config node.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Contains(System.Object)">
      <summary>
            Determines whether this collection contains the specified key.
            </summary>
      <param name="key">The key.</param>
      <returns>
        <c>true</c> if yes; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.Object,System.Object)">
      <summary>
            Adds the specified key.
            </summary>
      <remarks>
            Not implemented
            </remarks>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Remove(System.Object)">
      <summary>
            Removes the specified key.
            </summary>
      <param name="key">The key.</param>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copy the content to the specified array
            </summary>
      <param name="array">target array</param>
      <param name="index">target index</param>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Keys">
      <summary>
            Gets the keys.
            </summary>
      <value>The keys.</value>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Values">
      <summary>
            Gets the values.
            </summary>
      <value>The values.</value>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
      <value>
        <c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether this instance is fixed size.
            </summary>
      <value>
        <c>true</c> if this instance is fixed size; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Castle.Core.ParameterModel" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Count">
      <summary>
            Gets the count.
            </summary>
      <value>The count.</value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.SyncRoot">
      <summary>
            Gets the sync root.
            </summary>
      <value>The sync root.</value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether this instance is synchronized.
            </summary>
      <value>
        <c>true</c> if this instance is synchronized; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.PropertySet">
      <summary>
            Represents a property and the respective dependency.
            </summary>
    </member>
    <member name="M:Castle.Core.PropertySet.#ctor(System.Reflection.PropertyInfo,Castle.Core.DependencyModel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PropertySet" /> class.
            </summary>
      <param name="propertyInfo">The property info.</param>
      <param name="dependency">The dependency.</param>
    </member>
    <member name="P:Castle.Core.PropertySet.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.Core.PropertySet.Dependency">
      <summary>
            Gets the dependency.
            </summary>
      <value>The dependency.</value>
    </member>
    <member name="T:Castle.Core.PropertySetCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.PropertySet" /></summary>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.Add(Castle.Core.PropertySet)">
      <summary>
            Adds the specified property.
            </summary>
      <param name="property">The property.</param>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.FindByPropertyInfo(System.Reflection.PropertyInfo)">
      <summary>
            Finds a PropertySet the by PropertyInfo.
            </summary>
      <param name="info">The info.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.IResource">
      <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
      <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource" />
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
      <param name="relativePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Resource.IResource.FileBasePath">
      <summary>
      </summary>
      <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource.StreamHideCloseDelegate">
      <summary>
            Do not allow closing and disposal of the 
            underlying <see cref="P:Castle.Core.Resource.AbstractStreamResource.Stream" />.
            </summary>
    </member>
    <member name="T:Castle.Core.Resource.IResourceFactory">
      <summary>
            Depicts the contract for resource factories.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
      <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
      <remarks>
            Implementors should return <c>true</c>
            only if the given identificator is supported
            by the resource factory
            </remarks>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <param name="basePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.AssemblyResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.StaticContentResource">
      <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource" /></summary>
    </member>
    <member name="T:Castle.Core.Resource.UncResource">
      <summary>
            Enable access to files on network shares
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceEnabledComponent">
      <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider" /> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
      <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
      <summary>
            Wraps a reference that is passed 
            ByRef and provides indirect load/store support.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
      <summary>
            Summary description for NewArrayExpression.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil">
      <summary>
            Handles replication of custom attributes
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.InitializeConstructorArgs(System.Type,System.Attribute,System.Object[],System.Reflection.ParameterInfo[])">
      <summary>
            Here we try to match a constructor argument to its value.
            Since we can't get the values from the assembly, we use some heuristics to get it.
            a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
            b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
      <summary>
            We have the following rules here.
            Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
            we can convert it.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.ConvertValue(System.Object,System.Type)">
      <summary>
            Attributes can only accept simple types, so we return null for null,
            if the value is passed as string we call to string (should help with converting), 
            otherwise, we use the value as is (enums, integer, etc).
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
      <summary>
            Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
      <summary>
            Provides appropriate Ldind.X opcode for 
            the type of primitive value to be loaded indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.MethodEmitter.CopyParametersAndReturnTypeFrom(System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.Emitters.AbstractTypeEmitter)">
      <summary>
            Inspect the base method for generic definitions
            and set the return type and the parameters
            accordingly
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
      <summary>
            Emits a load opcode of the appropriate kind for a constant string or
            primitive value.
            </summary>
      <param name="gen">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a load opcode of the appropriate kind for the constant default value of a
            type, such as 0 for value types and null for reference types.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a load indirect opcode of the appropriate type for a value or object reference.
            Pops a pointer off the evaluation stack, dereferences it and loads
            a value of the specified type.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a store indirectopcode of the appropriate type for a value or object reference.
            Pops a value of the specified type and a pointer off the evaluation stack, and
            stores the value.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
      <summary>
            Summary description for PropertiesCollection.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
      <summary>
            Provides appropriate Stind.X opcode 
            for the type of primitive value to be stored indirectly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
      <summary>
            Base class that exposes the common functionalities
            to proxy generation.
            </summary>
      <remarks>
            TODO: 
            - Use the interceptor selector if provided
            - Add tests and fixes for 'leaking this' problem
            - Mixin support
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GetProxyTargetReference">
      <summary>
            Used by dinamically implement <see cref="T:Castle.Core.Interceptor.IProxyTargetAccessor" /></summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
      <summary>
            Generates a parameters constructor that initializes the proxy
            state with <see cref="T:Castle.Core.Interceptor.StandardInterceptor" /> just to make it non-null.
            <para>
            This constructor is important to allow proxies to be XML serializable
            </para></summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.BuildInvocationNestedType(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.ConstructorVersion)">
      <summary>
            If callbackMethod is null the InvokeOnTarget implementation 
            is just the code to throw an exception
            </summary>
      <param name="emitter">
      </param>
      <param name="targetType">
      </param>
      <param name="targetForInvocation">
      </param>
      <param name="methodInfo">
      </param>
      <param name="callbackMethod">
      </param>
      <param name="version">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.BuildInvocationNestedType(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.ConstructorVersion,System.Boolean)">
      <summary>
            If callbackMethod is null the InvokeOnTarget implementation
            is just the code to throw an exception
            </summary>
      <param name="emitter">
      </param>
      <param name="targetType">
      </param>
      <param name="targetForInvocation">
      </param>
      <param name="methodInfo">
      </param>
      <param name="callbackMethod">
      </param>
      <param name="version">
      </param>
      <param name="allowChangeTarget">If true the invocation will implement the IChangeProxyTarget interface</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.CreateIInvocationConstructor(System.Type,Castle.DynamicProxy.Generators.Emitters.NestedClassEmitter,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference,Castle.DynamicProxy.Generators.ConstructorVersion)">
      <summary>
            Generates the constructor for the nested class that extends
            <see cref="T:Castle.DynamicProxy.AbstractInvocation" /></summary>
      <param name="targetFieldType">
      </param>
      <param name="nested">
      </param>
      <param name="targetField">
      </param>
      <param name="version">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.CreateInitializeCacheMethodBody(System.Type,System.Reflection.MethodInfo[],Castle.DynamicProxy.Generators.Emitters.ClassEmitter,Castle.DynamicProxy.Generators.Emitters.ConstructorEmitter)">
      <summary>
            Improvement: this cache should be static. We should generate a
            type constructor instead
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AcceptMethod(System.Reflection.MethodInfo,System.Boolean)">
      <summary>
            Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook" />
            to select methods.
            </summary>
      <param name="method">
      </param>
      <param name="onlyVirtuals">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.IsAccessible(System.Reflection.MethodInfo)">
      <summary>
            Checks if the method is public or protected.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.ShouldCreateNewSlot(System.Reflection.MethodInfo)">
      <summary>
            Checks if the method has the same signature as a method that was marked as
            one that should generate a new vtable slot.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.ClassProxyGenerator">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.EventToGenerate.#ctor(Castle.DynamicProxy.Generators.Emitters.EventEmitter,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.EventAttributes)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.EventToGenerate" /> class.
            </summary>
      <param name="emitter">The emitter.</param>
      <param name="addMethod">The add method.</param>
      <param name="removeMethod">The remove method.</param>
      <param name="attributes">The attributes.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator.FindMethodOnTargetType(System.Reflection.MethodInfo,System.Type,System.Boolean)">
      <summary>
            Finds the type of the method on target.
            </summary>
      <param name="methodOnInterface">The method on interface.</param>
      <param name="proxyTargetType">Type of the proxy target.</param>
      <param name="checkMixins">if set to <c>true</c> will check implementation on mixins.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator.IsTypeEquivalent(System.Type,System.Type)">
      <summary>
            Checks whether the given types are the same. This is 
            more complicated than it looks.
            </summary>
      <param name="sourceType">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.InterfaceGeneratorType">
      <summary>
            This is used by the ProxyObjectReference class durin de-serialiation, to know
            which generator it should use
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
      <summary>
            Handles the deserialization of proxies.
            See here for more details:
            http://groups.google.com/group/castle-project-devel/msg/fb5ef9656d050ba5
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
      <summary>
            Usefull for test cases
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxySerializer">
      <summary>
            Assists in serializing instances of the generated proxy types so that they can be deserialized via <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" />.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxySerializer.Indirection">
      <summary>
            Used to circumvent a serialization bug, where direct self references and directly held delegates are not deserialized correctly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
      <summary>
            Used during the target type inspection process.
            Implementors have a chance to interfere in the
            proxy generation process
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
            Invoked by the generation process to know if
            the specified member should be proxied
            </summary>
      <param name="type">
      </param>
      <param name="memberInfo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonVirtualMemberNotification(System.Type,System.Reflection.MemberInfo)">
      <summary>
            Invoked by the generation process to notify that a
            member wasn't marked as virtual.
            </summary>
      <param name="type">
      </param>
      <param name="memberInfo">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
      <summary>
            Invoked by the generation process to notify 
            that the whole process is completed.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyBuilder">
      <summary>
            Abstracts the implementation of proxy constructions
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified type.
            </summary>
      <param name="theClass">The proxy base class.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            type and interfaces. The interfaces must be only "mark" interfaces
            </summary>
      <param name="theClass">
      </param>
      <param name="interfaces">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            interface that 'proceeds' executions to the 
            specified target.
            </summary>
      <param name="theInterface">
      </param>
      <param name="interfaces">
      </param>
      <param name="targetType">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            interface that delegate all executions to the 
            specified interceptor(s).
            </summary>
      <param name="theInterface">
      </param>
      <param name="interfaces">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            interface that delegate all executions to the
            specified interceptor(s) and uses an instance of the interface
            as their targets, rather than a class. All IInvocation's
            should then implement IChangeProxyTarget.
            </summary>
      <param name="theInterface">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternalToDynamicProxy(System.Reflection.Assembly)">
      <summary>
            Determines whether this assembly has internals visisble to dynamic proxy.
            </summary>
      <param name="asm">The asm.</param>
    </member>
    <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternal(System.Reflection.MethodInfo)">
      <summary>
            Determines whether the specified method is internal.
            </summary>
      <param name="method">The method.</param>
      <returns>
        <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.DynamicProxy.ModuleScope">
      <summary>
            Summary description for ModuleScope.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.moduleBuilderWithStrongName">
      <summary>
            Avoid leaks caused by non disposal of generated types.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.typeCache">
      <summary>
            Keep track of generated types
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope._lockobj">
      <summary>
            Used to lock the module builder creation
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class.
            </summary>
      <param name="savePhysicalAssembly">if set to <c>true</c> saves the generated module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
      <summary>
            Saves the generated assembly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
      <summary>
            ProxyBuilder that persists the generated type.
            </summary>
      <remarks>
            The saved assembly contains just the last generated type.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ProxyGenerationOptions">
      <summary>
            The proxy generation options, note that this is a statefull class with regard to mixin.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ProxyGenerationOptions.Default">
      <summary>
            Gets the default options
            </summary>
      <value>The default.</value>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.AddMixinInterfaceImplementation(System.Object)">
      <summary>
            This is required because a mixin may implement more than a single interface.
            In order to track that, we register them all here, and when we instansiate the proxy, we pass it the 
            mixins implementations, where each interface has an object that implements it.
            Example:
            FooBar foo implements IFoo and IBar
            
            proxy ctor would be:
            
            public Proxy(IFoo, IBar, IInterceptor[], object target)
            
            And will be invoked with:
            new Proxy(foo, foo, inteceptors, target);
            </summary>
      <param name="mixin">The mixin.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.InspectAndRegisterMixinInterfaces">
      <summary>
            Because we need to cache the types based on the mixed in mixins, we do the following here:
             - Get all the mixin interfaces
             - Sort them by full name
             - Return them by position
            
            The idea is to have reproducable behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="builder">The builder.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates the class proxy.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="interceptors">The interceptors.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.Core.Interceptor.IInterceptor[],System.Object[])">
      <summary>
            Creates the class proxy.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interceptors">The interceptors.</param>
      <param name="constructorArgs">The constructor args.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
      </summary>
      <param name="targetType">
      </param>
      <param name="options">
      </param>
      <param name="interceptors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates the class proxy.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
      <param name="constructorArgs">The constructor args.</param>
      <param name="interceptors">The interceptors.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
      <summary>
            Gets the proxy builder instance.
            </summary>
      <value>The proxy builder.</value>
    </member>
    <member name="M:Castle.DynamicProxy.RemotableInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.RemotableInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.DynamicProxy.RemotableInvocation.MethodInvocationTarget">
      <summary>
            For interface proxies, this will point to the
            <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="T:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector">
      <summary>
            Tries to obtain transaction configuration based on 
            the component configuration or (if not available) check
            for the attributes.
            </summary>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Tries to obtain transaction configuration based on 
            the component configuration or (if not available) check
            for the attributes.
            </summary>
      <param name="kernel">The kernel.</param>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.ConfigureBasedOnAttributes(Castle.Core.ComponentModel)">
      <summary>
            Tries to configure the ComponentModel based on attributes.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.ObtainNodeName">
      <summary>
            Obtains the name of the 
            node (overrides MethodMetaInspector.ObtainNodeName)
            </summary>
      <returns>the node name on the configuration</returns>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.ProcessMeta(Castle.Core.ComponentModel,System.Reflection.MethodInfo[],Castle.Core.MethodMetaModel)">
      <summary>
            Processes the meta information available on
            the component configuration. (overrides MethodMetaInspector.ProcessMeta)
            </summary>
      <param name="model">The model.</param>
      <param name="methods">The methods.</param>
      <param name="metaModel">The meta model.</param>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.Validate(Castle.Core.ComponentModel,Castle.Facilities.AutomaticTransactionManagement.TransactionMetaInfoStore)">
      <summary>
            Validates the type is OK to generate a proxy.
            </summary>
      <param name="model">The model.</param>
      <param name="store">The store.</param>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.IsMarkedWithTransactional(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Determines whether the configuration has <c>istransaction="true"</c> attribute.
            </summary>
      <param name="configuration">The configuration.</param>
      <returns>
        <c>true</c> if yes; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.AssertThereNoTransactionOnConfig(Castle.Core.ComponentModel)">
      <summary>
            Asserts that if there are transaction behavior
            configured for methods, the component node has <c>istransaction="true"</c> attribute
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionComponentInspector.AddTransactionInterceptorIfIsTransactional(Castle.Core.ComponentModel,Castle.Facilities.AutomaticTransactionManagement.TransactionMetaInfoStore)">
      <summary>
            Associates the transaction interceptor with the ComponentModel.
            </summary>
      <param name="model">The model.</param>
      <param name="store">The meta information store.</param>
    </member>
    <member name="T:Castle.Facilities.AutomaticTransactionManagement.TransactionFacility">
      <summary>
            Augments the kernel to handle transactional components
            </summary>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionFacility.Init">
      <summary>
            Registers the interceptor component, the metainfo store and
            adds a contributor to the ModelBuilder
            </summary>
    </member>
    <member name="T:Castle.Facilities.AutomaticTransactionManagement.TransactionInterceptor">
      <summary>
            Intercepts call for transactional components, coordinating
            the transaction creation, commit/rollback accordingly to the 
            method execution. Rollback is invoked if an exception is threw.
            </summary>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionInterceptor.#ctor(Castle.MicroKernel.IKernel,Castle.Facilities.AutomaticTransactionManagement.TransactionMetaInfoStore)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.AutomaticTransactionManagement.TransactionInterceptor" /> class.
            </summary>
      <param name="kernel">The kernel.</param>
      <param name="infoStore">The info store.</param>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionInterceptor.SetInterceptedComponentModel(Castle.Core.ComponentModel)">
      <summary>
            Sets the intercepted component's ComponentModel.
            </summary>
      <param name="target">The target's ComponentModel</param>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionInterceptor.Intercept(Castle.Core.Interceptor.IInvocation)">
      <summary>
            Intercepts the specified invocation and creates a transaction
            if necessary.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Facilities.AutomaticTransactionManagement.TransactionInterceptor.Logger">
      <summary>
            Gets or sets the logger.
            </summary>
      <value>The logger.</value>
    </member>
    <member name="T:Castle.Facilities.AutomaticTransactionManagement.TransactionMetaInfoStore">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="M:Castle.Facilities.AutomaticTransactionManagement.TransactionMetaInfo.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.AutomaticTransactionManagement.TransactionMetaInfo" /> class.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IComponentActivator">
      <summary>
            Implements the instance creation logic. The default
            implementation should rely on an ordinary call to 
            Activator.CreateInstance(). 
            </summary>
      <remarks>
            This interface is provided in order to allow custom components
            to be created using a different logic, such as using a specific factory
            or builder.
            <para>
            The constructor for implementation has the following signature:
            </para><code>
            ComponentModel model, IKernel kernel, 
            ComponentInstanceDelegate onCreation, 
            ComponentInstanceDelegate onDestruction
            </code><para>
            The Activator should raise the events onCreation and onDestruction
            in order to correctly implement the contract. Usually the best
            way of creating a custom activator is by extending the existing ones.
            </para><seealso cref="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator" /><seealso cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator" /></remarks>
    </member>
    <member name="M:Castle.MicroKernel.IComponentActivator.Create(Castle.MicroKernel.CreationContext)">
      <summary>
            Should return a new component instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IComponentActivator.Destroy(System.Object)">
      <summary>
            Should perform all necessary work to dispose the instance
            and/or any resource related to it.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator">
      <summary>
            Abstract implementation of <see cref="T:Castle.MicroKernel.IComponentActivator" />.
            The implementors must only override the InternalCreate and 
            InternalDestroy methods in order to perform their creation and
            destruction logic.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Constructs an AbstractComponentActivator
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.ComponentActivatorException">
      <summary>
            Summary description for ComponentActivatorException.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator">
      <summary>
            Standard implementation of <see cref="T:Castle.MicroKernel.IComponentActivator" />.
            Handles the selection of the best constructor, fills the
            writable properties the component exposes, run the commission 
            and decommission lifecycles, etc.
            </summary>
      <remarks>
            Custom implementors can just override the <c>CreateInstance</c> method.
            Please note however that the activator is responsible for the proxy creation
            when needed.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator" /> class.
            </summary>
      <param name="model">
      </param>
      <param name="kernel">
      </param>
      <param name="onCreation">
      </param>
      <param name="onDestruction">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator">
      <summary>
            Attempts to dynamically load a UserControl by invoking Page.LoadControl.  
            There are two uses of this class.  
            <para>
            1) Add a component to the Kernel and add a VirtualPath attribute specifying 
            the relative path of the .ascx file for the associated UserControl. (easy)
            </para><example><code>
                &lt;component id="BasketView" 
                  service="Castle.ShoppingCart.IBasketView, Castle.ShoppingCart"
                  type="Castle.ShoppingCart.BasketView, Castle.ShoppingCart" 
                  lifestyle="transient"
                  virtualPath="~/Views/BasketView.ascx"
                /&gt;
              </code></example><para>
            2) Precompile a UserControl and add the pre-compiled class to the Kernel. (hard)  
            Has not been tested with proxies.
            </para></summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="kernel">The kernel.</param>
      <param name="onCreation">The on creation.</param>
      <param name="onDestruction">The on destruction.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.CreateInstance(Castle.MicroKernel.CreationContext,System.Object[],System.Type[])">
      <summary>
            Creates the instance.
            </summary>
      <param name="context">The context.</param>
      <param name="arguments">The arguments.</param>
      <param name="signature">The signature.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.ISubDependencyResolver">
      <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ISubDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>
            Should return an instance of a service or property values as
            specified by the dependency model instance. 
            It is also the responsability of <see cref="T:Castle.MicroKernel.IDependencyResolver" />
            to throw an exception in the case a non-optional dependency 
            could not be resolved.
            </summary>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="parentResolver">Parent resolver</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>The dependency resolved value or null</returns>
    </member>
    <member name="M:Castle.MicroKernel.ISubDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>
            Returns true if the resolver is able to satisfy this dependency.
            </summary>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="parentResolver">Parent resolver</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>
        <c>true</c> if the dependency can be satisfied</returns>
    </member>
    <member name="T:Castle.MicroKernel.CreationContext">
      <summary>
            Used during a component request, passed along to the whole process.
            This allow some data to be passed along the process, which is used 
            to detected cycled dependency graphs and now it's also being used
            to provide arguments to components.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.CreationContext.handler">
      <summary>
      </summary>
    </member>
    <member name="F:Castle.MicroKernel.CreationContext.dependencies">
      <summary>
            Holds the scoped dependencies being resolved. 
            If a dependency appears twice on the same scope, we'd have a cycle.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.CreationContext.Empty">
      <summary>Creates a new, empty <see cref="T:Castle.MicroKernel.CreationContext" /> instance.</summary>
      <remarks>A new CreationContext should be created every time, as the contexts keeps some state related to dependency resolution.</remarks>
    </member>
    <member name="P:Castle.MicroKernel.CreationContext.Handler">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.DependencyTrackingScope.DependencyModelExtended">
      <summary>
            Extends <see cref="T:Castle.Core.DependencyModel" /> adding <see cref="T:System.Reflection.MemberInfo" /> and <see cref="T:Castle.Core.ComponentModel" />
            information. Th MemberInfo is only useful to provide detailed information 
            on exceptions. 
            The ComponentModel is required so we can get resolve an object that takes as a parameter itself, but
            with difference model. (See IoC 51 for the details)
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Exceptions.CircularDependencyException">
      <summary>
            Exception throw when a circular dependency is detected
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException" /> class.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is <see langword="null" />.</exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <see langword="null" /> or <see cref="P:System.Exception.HResult" /> is zero (0).</exception>
    </member>
    <member name="T:Castle.MicroKernel.ComponentNotFoundException">
      <summary>
            Exception threw when a request for a component
            cannot be satisfied because the component does not
            exist in the container
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException" /> class.
            </summary>
      <param name="service">The service.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentRegistrationException">
      <summary>
            Exception threw when there is a problem
            registering a component
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.KernelException">
      <summary>
            Exception threw by Kernel operations that failed
            for some reason.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.MicroKernel.KernelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.Facilities.FacilityException">
      <summary>
            Base exception to be used by facilities.
            </summary>
    </member>
    <member name="T:Castle.Facilities.EventWiring.EventWiringException">
      <summary>
            Exception that is thrown when a error occurs during the Event Wiring process
            </summary>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.IFacility">
      <summary>
            Unit of extension. A facility should use 
            the extension points offered by the kernel
            to augment its functionality.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
      <summary>
      </summary>
      <param name="kernel">
      </param>
      <param name="facilityConfig">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IFacility.Terminate">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.MicroKernel.Facilities.AbstractFacility">
      <summary>
            Base class for facilities. 
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init">
      <summary>
            The custom initialization for the Facility.
            </summary>
      <remarks>It must be overriden.</remarks>
    </member>
    <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Initializes the facility. First it performs the initialization common for all 
            facilities, setting the <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel" /> and the 
            <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig" />. After it, the <c>Init</c> method is invoked
            and the custom initilization is perfomed.
            </summary>
      <param name="kernel">
      </param>
      <param name="facilityConfig">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Terminate">
      <summary>
            Terminates the Facility, invokind the <see cref="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose" /> and setting 
            the Kernel to a null reference.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose">
      <summary>
            Performs the tasks associated with freeing, releasing, or resetting 
            the facility resources.
            </summary>
      <remarks>It can be overriden.</remarks>
    </member>
    <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel">
      <summary>
            Gets the <see cref="T:Castle.MicroKernel.IKernel" /> where the facility is registered.
            </summary>
      <value>The <see cref="T:Castle.MicroKernel.IKernel" />.</value>
    </member>
    <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig">
      <summary>
            Gets the facility configuration.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.IConfiguration" /> representing 
            the facility configuration.</value>
    </member>
    <member name="T:Castle.Facilities.EventWiring.EventWiringFacility">
      <summary>
             Facility to allow components to dynamically subscribe to events offered by 
             other components. We call the component that offers events publishers and 
             the components that uses them, subscribers.
             </summary>
      <remarks>
             A component that wish to subscribe to an event must use the external configuration
             adding a node <c>subscribers</c> on the publisher. This node can have multiple entries using the 
             <c>subscriber</c> node.
             </remarks>
      <example>
        <para>This example shows two simple components: one is the event publisher and the other is the 
             subscriber. The subscription will be done by the facility, using the publisher associated configuration.</para>
        <para>The Publisher class:</para>
        <code>
             public class SimplePublisher
            	{
            		public event PublishEventHandler Event;
            
            		public void Trigger()
            		{
            			if (Event != null)
            			{
            				Event(this, new EventArgs()); 
            			}
            		}
             }
             </code>
        <para>The Subscriber class:</para>
        <code>
             public class SimpleListener
             {
             	private bool _listened;
             	private object _sender;
             
             	public void OnPublish(object sender, EventArgs e)
             	{
             		_sender = sender; 
             		_listened = sender != null;
             	}
             
             	public bool Listened
             	{
             		get { return _listened;	}
             	}
             
             	public object Sender
             	{
             		get { return _sender; }
             	}
             }
             </code>
        <para>The configuration file:</para>
        <code><![CDATA[
             <?xml version="1.0" encoding="utf-8" ?>
             <configuration>
             	<facilities>
             		<facility 
             			id="event.wiring"
             			type="Castle.Facilities.EventWiring.EventWiringFacility, Castle.MicroKernel" />
             	</facilities>
             
             	<components>
             		<component 
             			id="SimpleListener" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimpleListener, Castle.Facilities.EventWiring.Tests" />
             
             		<component 
             			id="SimplePublisher" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimplePublisher, Castle.Facilities.EventWiring.Tests" >
             			<subscribers>
             				<subscriber id="SimpleListener" event="Event" handler="OnPublish"/>
             			</subscribers>
             		</component>
             	</components>
             </configuration>
             ]]></code>
      </example>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.Init">
      <summary>
            Overriden. Initializes the facility, subscribing to the <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated" />,
            <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentCreated" />, <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed" /> Kernel events.
            </summary>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentModelCreated(Castle.Core.ComponentModel)">
      <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            parses the configuration (the subscribers node) getting the event wiring info.
            </summary>
      <param name="model">The component model.</param>
      <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">Invalid and/or a error in the configuration</exception>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentCreated(Castle.Core.ComponentModel,System.Object)">
      <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            iterates the subscribers starting them and wiring the events.
            </summary>
      <param name="model">The component model.</param>
      <param name="instance">The instance representing the component.</param>
      <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">When the subscriber is not found
            <br /> or <br />
            The handler method isn't found
            <br /> or <br />
            The event isn't found
            </exception>
    </member>
    <member name="T:Castle.Facilities.EventWiring.WireInfo">
      <summary>
            Represents the information about an event.
            </summary>
    </member>
    <member name="M:Castle.Facilities.EventWiring.WireInfo.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.WireInfo" /> class.
            </summary>
      <param name="eventName">Name of the event.</param>
      <param name="handler">The name of the handler method.</param>
    </member>
    <member name="M:Castle.Facilities.EventWiring.WireInfo.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object"></see>.
            </returns>
    </member>
    <member name="M:Castle.Facilities.EventWiring.WireInfo.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
      <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>.</param>
      <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
    </member>
    <member name="P:Castle.Facilities.EventWiring.WireInfo.EventName">
      <summary>
            Gets the name of the event.
            </summary>
      <value>The name of the event.</value>
    </member>
    <member name="P:Castle.Facilities.EventWiring.WireInfo.Handler">
      <summary>
            Gets the handler method name.
            </summary>
      <value>The handler.</value>
    </member>
    <member name="T:Castle.Facilities.FactorySupport.FactoryActivator">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Facilities.Remoting.RemoteActivator">
      <summary>
            Activates a object connecting to the remote server.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemoteActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteActivator" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="kernel">The kernel.</param>
      <param name="onCreation">The oncreation event handler.</param>
      <param name="onDestruction">The ondestruction event handler.</param>
    </member>
    <member name="T:Castle.Facilities.Remoting.RemoteActivatorThroughConnector">
      <summary>
            Activates a client connecting to the remote server, enforcing the uri and the server activation.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemoteActivatorThroughConnector.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteActivatorThroughConnector" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="kernel">The kernel.</param>
      <param name="onCreation">The oncreation event handler.</param>
      <param name="onDestruction">The ondestruction event handler.</param>
    </member>
    <member name="T:Castle.Facilities.Remoting.RemoteActivatorThroughRegistry">
      <summary>
            Activates a client connecting to the remote server through the <see cref="T:Castle.Facilities.Remoting.RemotingRegistry" />.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemoteActivatorThroughRegistry.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteActivatorThroughRegistry" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="kernel">The kernel.</param>
      <param name="onCreation">The oncreation envent handler.</param>
      <param name="onDestruction">The ondestruction event handler.</param>
    </member>
    <member name="T:Castle.Facilities.Remoting.RemoteClientActivatedActivator">
      <summary>
            Activates a client activated object.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemoteClientActivatedActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteClientActivatedActivator" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="kernel">The kernel.</param>
      <param name="onCreation">The oncreation event handler.</param>
      <param name="onDestruction">The ondestruction event handler.</param>
    </member>
    <member name="T:Castle.Facilities.Remoting.RemoteMarshallerActivator">
      <summary>
            Activates and publishes a server object.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemoteMarshallerActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteMarshallerActivator" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="kernel">The kernel.</param>
      <param name="onCreation">The oncreation event handler.</param>
      <param name="onDestruction">The ondestruction event handler.</param>
    </member>
    <member name="T:Castle.Facilities.Remoting.RemotingFacility">
      <summary>
            Facility to allow the communication with remote kernel, using the .NET Remoting infraestructure.
            </summary>
      <remarks>
            TODO
            </remarks>
      <example>
            TODO
            </example>
    </member>
    <member name="F:Castle.Facilities.Remoting.RemotingFacility.baseUri">
      <summary>
            Used for client side (Expand explanation)
            </summary>
    </member>
    <member name="F:Castle.Facilities.Remoting.RemotingFacility.localRegistry">
      <summary>
            Used for server side. 
            Holds the local registry
            </summary>
    </member>
    <member name="F:Castle.Facilities.Remoting.RemotingFacility.remoteRegistry">
      <summary>
            Used for client side. 
            Holds a remote proxy to the server registry
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemotingFacility.#ctor">
      <summary>
            Constructs a RemotingFacility
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemotingFacility.Dispose">
      <summary>
            Performs the tasks associated with freeing, releasing, or resetting
            the facility resources.
            </summary>
      <remarks>It can be overriden.</remarks>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction">
      <summary>
            Implementors must inspect the component for 
            a given information or parameter.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Usually the implementation will look in the configuration property 
            of the model or the service interface, or the implementation looking for
            something.
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
    </member>
    <member name="T:Castle.Facilities.Remoting.RemotingInspector">
      <summary>
            Inspects the model looking for remote component configuration. If found, 
            do the component Remoting configuration.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemotingInspector.#ctor(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter,System.Boolean,System.Boolean,System.String,Castle.Facilities.Remoting.RemotingRegistry,Castle.Facilities.Remoting.RemotingRegistry)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemotingInspector" /> class.
            </summary>
      <param name="converter">The converter.</param>
      <param name="isServer">if set to <c>true</c> is a server.</param>
      <param name="isClient">if set to <c>true</c> is a client.</param>
      <param name="baseUri">The base URI.</param>
      <param name="remoteRegistry">The remote registry.</param>
      <param name="localRegistry">The local registry.</param>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemotingInspector.ResetDependencies(Castle.Core.ComponentModel)">
      <summary>
            Client components are not created by the container
            so there's no point collecting constructor dependencies
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.Facilities.Remoting.RemotingRegistry.GetModel(System.Type)">
      <summary>
            Used in case of generics:
            </summary>
      <param name="serviceType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacility.CheckWaitingList">
      <summary>
            For each new component registered,
            some components in the WaitingDependency
            state may have became valid, so we check them
            </summary>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacility.Start(System.String)">
      <summary>
            Request the component instance
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.ILifecycleConcern">
      <summary>
            Summary description for ILifecycleConcern.
            </summary>
    </member>
    <member name="T:Castle.Facilities.TypedFactory.FactoryInterceptor">
      <summary>
            Summary description for FactoryInterceptor.
            </summary>
    </member>
    <member name="T:Castle.Facilities.TypedFactory.TypedFactoryFacility">
      <summary>
            Summary description for TypedFactoryFacility.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IHandler">
      <summary>
            Contract for the IHandler, which manages an
            component state and coordinates its creation 
            and destruction (dispatching to activators, lifestyle managers)
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.Init(Castle.MicroKernel.IKernel)">
      <summary>
            Initializes the handler with a reference to the
            kernel.
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.Resolve(Castle.MicroKernel.CreationContext)">
      <summary>
            Implementors should return a valid instance 
            for the component the handler is responsible.
            It should throw an exception in the case the component
            can't be created for some reason
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.Release(System.Object)">
      <summary>
            Implementors should dispose the component instance
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.AddCustomDependencyValue(System.String,System.Object)">
      <summary>
            Dictionary of String/object used to 
            associate data with a component dependency.
            For example, if you component SmtpServer depends on 
            host and port, you can add those to this
            dictionary and the handler will be able to use them.
            </summary>
      <remarks>
            TODO: Document this
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.RemoveCustomDependencyValue(System.String)">
      <summary>
            TODO: Document this
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.HasCustomParameter(System.String)">
      <summary>
            TODO: Document this
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.IHandler.CurrentState">
      <summary>
            Gets the state of the handler
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IHandler.ComponentModel">
      <summary>
            Gets the model of the component being 
            managed by this handler.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IHandler.OnHandlerStateChanged">
      <summary>
            TODO: Document this
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.IExposeDependencyInfo">
      <summary>
            Might be implemented by a handler 
            so it can expose access to dependency information 
            which is used to construct meaningful error messages
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.IExposeDependencyInfo.ObtainDependencyDetails(System.Collections.IList)">
      <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            <param name="dependenciesChecked">list of the dependecies that was already checked, used to avoid cycles.</param></summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.AbstractHandler">
      <summary>
            Implements the basis of <see cref="T:Castle.MicroKernel.IHandler" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByService">
      <summary>
            Dictionary of Type to a list of <see cref="T:Castle.Core.DependencyModel" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByKey">
      <summary>
            Dictionary of key (string) to <see cref="T:Castle.Core.DependencyModel" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.customParameters">
      <summary>
            Custom dependencies values associated with the handler
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.lifestyleManager">
      <summary>
            Lifestyle manager instance
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.#ctor(Castle.Core.ComponentModel)">
      <summary>
            Constructs and initializes the handler
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Init(Castle.MicroKernel.IKernel)">
      <summary>
            Saves the kernel instance, subscribes to 
            <see cref="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel" /> event,
            creates the lifestyle manager instance and computes
            the handler state.
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.CreationContext)">
      <summary>
            Should be implemented by derived classes: 
            returns an instance of the component this handler
            is responsible for
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Release(System.Object)">
      <summary>
            Should be implemented by derived classes: 
            disposes the component instance (or recycle it)
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddCustomDependencyValue(System.String,System.Object)">
      <summary>
            TODO: Pendent
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.HasCustomParameter(System.String)">
      <summary>
            TODO: Pendent
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.RemoveCustomDependencyValue(System.String)">
      <summary>
            TODO: Pendent
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ObtainDependencyDetails(System.Collections.IList)">
      <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.CreateLifestyleManager(Castle.MicroKernel.IComponentActivator)">
      <summary>
            Creates an implementation of <see cref="T:Castle.MicroKernel.ILifestyleManager" /> based
            on <see cref="T:Castle.Core.LifestyleType" /> and invokes <see cref="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel)" />
            to initialize the newly created manager.
            </summary>
      <param name="activator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied">
      <summary>
            Checks if the handler is able to, at very least, satisfy
            the dependencies for the constructor with less parameters
            </summary>
      <remarks>
            For each non*optional dependency, the implementation will invoke 
            <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)" /></remarks>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)">
      <summary>
            Invoked by <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied" />
            in order to check if a dependency can be satisfied.
            If not, the handler is set to a 'waiting dependency' state.
            </summary>
      <remarks>
            This method registers the dependencies within the correct collection 
            or dictionary and changes the handler state to 
            <see cref="F:Castle.MicroKernel.HandlerState.WaitingDependency" /></remarks>
      <param name="dependency">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.DependencySatisfied(Castle.MicroKernel.IHandler,System.Boolean@)">
      <summary>
            Invoked by the kernel
            when one of registered dependencies were satisfied by 
            new components registered.
            </summary>
      <remarks>
            Handler for the event <see cref="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered" /></remarks>
      <param name="handler">
      </param>
      <param name="stateChanged">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.OnAddedAsChildKernel(System.Object,System.EventArgs)">
      <summary>
            Invoked whe the container receives a parent container reference.
            </summary>
      <remarks>
            This method implementation checks whether the parent container
            is able to supply the dependencies for this handler.
            </remarks>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.HandlerStateChanged(System.Object,System.EventArgs)">
      <summary>
            Handler for the event <see cref="E:Castle.MicroKernel.Handlers.AbstractHandler.OnHandlerStateChanged" /></summary>
      <param name="source">
      </param>
      <param name="args">
      </param>
    </member>
    <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.CurrentState">
      <summary>
            Gets the handler state.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.ComponentModel">
      <summary>
            Gets the component model.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.Handlers.AbstractHandler.OnHandlerStateChanged">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.DefaultGenericHandler">
      <summary>
            Summary description for DefaultGenericHandler.
            </summary>
      <remarks>
            TODO: Consider refactoring AbstractHandler moving lifestylemanager
            creation to DefaultHandler
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.#ctor(Castle.Core.ComponentModel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.DefaultGenericHandler" /> class.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.DefaultHandler">
      <summary>
            Summary description for DefaultHandler.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.#ctor(Castle.Core.ComponentModel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.DefaultHandler" /> class.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.Resolve(Castle.MicroKernel.CreationContext)">
      <summary>
            Returns an instance of the component this handler
            is responsible for
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.Release(System.Object)">
      <summary>
            disposes the component instance (or recycle it)
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.IHandlerFactory">
      <summary>
            Extension point to allow the developer
            to use his implementation of <see cref="T:Castle.MicroKernel.IHandler" /></summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.DefaultHandlerFactory">
      <summary>
            Summary description for DefaultHandlerFactory.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.HandlerException">
      <summary>
            Summary description for HandlerException.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.HandlerState">
      <summary>
            Possible states for a IHandler instance
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.HandlerState.Valid">
      <summary>
            The component can be requested
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.HandlerState.WaitingDependency">
      <summary>
            The component can not be requested 
            as it still depending on a external 
            dependency not yet available
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.HandlerStateDelegate">
      <summary>
      </summary>
      <param name="source">
      </param>
      <param name="args">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver">
      <summary>
            Redirects resolution to the main resolver, and if not found uses
            the parent handler.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.ISubDependencyResolver)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver" /> class.
            </summary>
      <param name="parentHandler">The parent handler.</param>
      <param name="childResolver">The child resolver.</param>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.DisposalConcern">
      <summary>
            Summary description for DisposalConcern.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.InitializationConcern">
      <summary>
            Summary description for InitializationConcern.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern">
      <summary>
            Summary description for SupportInitializeConcern.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.Pool.IPool">
      <summary>
            Pool implementation contract. 
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Request(Castle.MicroKernel.CreationContext)">
      <summary>
            Implementors should return a component instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Release(System.Object)">
      <summary>
            Implementors should release the instance or put it
            on the pool
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.Pool.DefaultPool.InitPool">
      <summary>
            Initializes the pool to a initial size by requesting
            n components and then releasing them.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ILifestyleManager">
      <summary>
            The <c>ILifestyleManager</c> implements 
            a strategy for a given lifestyle, like singleton, perthread
            and transient.
            </summary>
      <remarks>
            The responsability of <c>ILifestyleManager</c>
            is only the management of lifestyle. It should rely on
            <see cref="T:Castle.MicroKernel.IComponentActivator" /> to obtain a new component instance
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel)">
      <summary>
            Initializes the <c>ILifestyleManager</c> with the 
            <see cref="T:Castle.MicroKernel.IComponentActivator" /></summary>
      <param name="componentActivator">
      </param>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ILifestyleManager.Resolve(Castle.MicroKernel.CreationContext)">
      <summary>
            Implementors should return the component instance based 
            on the lifestyle semantic.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ILifestyleManager.Release(System.Object)">
      <summary>
            Implementors should release the component instance based
            on the lifestyle semantic, for example, singleton components
            should not be released on a call for release, instead they should
            release them when disposed is invoked.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager">
      <summary>
            Summary description for AbstractLifestyleManager.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager">
      <summary>
            Summary description for PerThreadLifestyleManager.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager.Dispose">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleManager">
      <summary>
            Implements a Lifestyle Manager for Web Apps that
            create at most one object per web request.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.PoolableLifestyleManager">
      <summary>
            Implements a Poolable Lifestyle Manager. 
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.SingletonLifestyleManager">
      <summary>
            Summary description for SingletonLifestyleManager.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.TransientLifestyleManager">
      <summary>
            Summary description for TransientLifestyleManager.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector">
      <summary>
            Inspects the component configuration and the type looking for a
            definition of component activator type. The configuration preceeds whatever
            is defined in the component.
            </summary>
      <remarks>
            This inspector is not guarantee to always set up an component activator type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to establish a default component activator for components.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Seaches for the component activator in the configuration and, if unsuccessful
            look for the component activator attribute in the implementation type.
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The model instance</param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromConfiguration(Castle.Core.ComponentModel)">
      <summary>
            Reads the attribute "componentActivatorType" associated with the 
            component configuration and verifies it implements the <see cref="T:Castle.MicroKernel.IComponentActivator" /> 
            interface. 
            </summary>
      <exception cref="T:System.Configuration.ConfigurationException">
            If the type does not implement the proper interface
            </exception>
      <param name="model">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromType(Castle.Core.ComponentModel)">
      <summary>
            Check if the type expose one of the component activator attributes
            defined in Castle.Core namespace.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ValidateComponentActivator(System.Type)">
      <summary>
            Validates that the provide type implements IComponentActivator
            </summary>
      <param name="customComponentActivator">The custom component activator.</param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector">
      <summary>
            Uses the ConfigurationStore registered in the kernel to obtain
            an <see cref="T:Castle.Core.Configuration.IConfiguration" /> associated with the component.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Queries the kernel's ConfigurationStore for a configuration
            associated with the component name.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector">
      <summary>
            Check for a node 'parameters' within the component 
            configuration. For each child it, a ParameterModel is created
            and added to ComponentModel's Parameters collection
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Inspect the configuration associated with the component
            and populates the parameter model collection accordingly
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector">
      <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction" />
            collects all available constructors and populates them in the model
            as candidates. The Kernel will pick up one of the candidates
            according to a heuristic.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ExtendedPropertiesConstants">
      <summary>
            Only to hold internal constants and get rid of 
            magic numbers and hardcode names.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.GenericInspector">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector">
      <summary>
            Inspect the component for <c>InterceptorAttribute</c> and
            the configuration for the interceptors node
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector">
      <summary>
            Inspects the type looking for interfaces that constitutes
            lifecycle interfaces, defined in the Castle.Model namespace.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Checks if the type implements <see cref="T:Castle.Core.IInitializable" /> and or
            <see cref="T:System.IDisposable" /> interfaces.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector">
      <summary>
            Inspects the component configuration and the type looking for a
            definition of lifestyle type. The configuration preceeds whatever
            is defined in the component.
            </summary>
      <remarks>
            This inspector is not guarantee to always set up an lifestyle type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to estabish a default lifestyle for components.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Seaches for the lifestyle in the configuration and, if unsuccessful
            look for the lifestyle attribute in the implementation type.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromConfiguration(Castle.Core.ComponentModel)">
      <summary>
            Reads the attribute "lifestyle" associated with the 
            component configuration and tries to convert to <see cref="T:Castle.Core.LifestyleType" /> 
            enum type. 
            </summary>
      <exception cref="T:System.Configuration.ConfigurationException">
            If the conversion fails
            </exception>
      <param name="model">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromType(Castle.Core.ComponentModel)">
      <summary>
            Check if the type expose one of the lifestyle attributes
            defined in Castle.Model namespace.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector">
      <summary>
            Base for inspectors that want configuration associated with methods.
            For each child a <see cref="T:Castle.Core.MethodMetaModel" /> is created
            and added to ComponentModel's methods collection
            </summary>
      <remarks>
            Implementors should override the <see cref="M:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector.ObtainNodeName" /> return
            the name of the node to be inspected. For example:
            <code><pre><transactions><method name="Save" transaction="requires" /></transactions></pre></code></remarks>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector">
      <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction" />
            collects all potential writable puplic properties exposed by the component 
            implementation and populates the model with them.
            The Kernel might be able to set some of these properties when the component 
            is requested.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Adds the properties as optional dependencies of this component.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.IComponentModelBuilder">
      <summary>
            Implementors must construct a populated
            instance of ComponentModel by inspecting the component
            and|or the configuration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
      <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
            "To give or supply in common with others; give to a 
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
            Removes the specified contributor
            </summary>
      <param name="contributor">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder">
      <summary>
            Summary description for DefaultComponentModelBuilder.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.#ctor(Castle.MicroKernel.IKernel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder" /> class.
            </summary>
      <param name="kernel">The kernel.</param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
      <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
            "To give or supply in common with others; give to a
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
      <param name="contributor">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
            Removes the specified contributor
            </summary>
      <param name="contributor">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.InitializeContributors">
      <summary>
            Initializes the default contributors.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.Contributors">
      <summary>
            Gets the contributors.
            </summary>
      <value>The contributors.</value>
    </member>
    <member name="T:Castle.MicroKernel.IProxyFactory">
      <summary>
            Defines the contract used by the kernel 
            to obtain proxies for components. The implementor
            must return a proxied instance that dispatch 
            the invocation to the registered interceptors in the model
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,System.Object[])">
      <summary>
            Implementors must create a proxy based on 
            the information exposed by ComponentModel
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
      <param name="instance">The component instance to be proxy (only required in some cases)</param>
      <param name="constructorArguments">array of parameters to the constructor (if any)</param>
      <returns>proxy instance</returns>
    </member>
    <member name="M:Castle.MicroKernel.IProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Implementor should check the component model
            and determine if the caller must pass on the component 
            instance to the proxy
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
      <returns>
        <c>true</c> if an instance must be passed to <see cref="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,System.Object[])" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Proxy.NotSupportedProxyFactory">
      <summary>
            This is a placeholder implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" />.
            </summary>
      <remarks>
            The decision to supply no implementation for <see cref="T:Castle.MicroKernel.IProxyFactory" />
            is supported by the fact that the MicroKernel should be a thin
            assembly with the minimal set of features, although extensible.
            Providing the support for this interface would obligate 
            the user to import another assembly, even if the large majority of
            simple cases, no use use of interceptors will take place.
            If you want to use however, see the Windsor container.
            </remarks>
    </member>
    <member name="T:Castle.MicroKernel.IReleasePolicy">
      <summary>
            Summary description for IReleasePolicy.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Releasers.AllComponentsReleasePolicy">
      <summary>
            Summary description for AllComponentsReleasePolicy.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy">
      <summary>
            Only tracks components that have decommission steps
            registered
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy" /> class.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy">
      <summary>
            No tracking of component instances are made.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy" /> class.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IDependencyResolver">
      <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IDependencyResolver.Initialize(Castle.MicroKernel.DependencyDelegate)">
      <summary>
            This method is called with a delegate for firing the
            IKernelEvents.DependencyResolving event.
            </summary>
      <param name="resolving">The delegate used to fire the event</param>
    </member>
    <member name="M:Castle.MicroKernel.IDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>
            Registers a sub resolver instance
            </summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="M:Castle.MicroKernel.IDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>
            Unregisters a sub resolver instance previously registered
            </summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver">
      <summary>
            Default implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver" />.
            This implementation is quite simple, but still should be useful
            for 99% of situations. 
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.#ctor(Castle.MicroKernel.IKernel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver" /> class.
            </summary>
      <param name="kernel">The kernel.</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Initialize(Castle.MicroKernel.DependencyDelegate)">
      <summary>
            Initializes this instance with the specified dependency delegate.
            </summary>
      <param name="dependencyDelegate">The dependency delegate.</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>
            Registers a sub resolver instance
            </summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>
            Unregisters a sub resolver instance previously registered
            </summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>
            Returns true if the resolver is able to satisfy the specified dependency.
            </summary>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="parentResolver">Parent resolver</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>
        <c>true</c> if the dependency can be satisfied</returns>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>
            Try to resolve the dependency by checking the parameters in 
            the model or checking the Kernel for the requested service.
            </summary>
      <remarks>
            The dependency resolver has the following precedence order:
            <list type="bullet"><item><description>
            The dependency is checked within the <see cref="T:Castle.MicroKernel.CreationContext" /></description></item><item><description>
            The dependency is checked within the <see cref="T:Castle.MicroKernel.IHandler" /> instance for the component
            </description></item><item><description>
            The dependency is checked within the registered <see cref="T:Castle.MicroKernel.ISubDependencyResolver" />s
            </description></item><item><description>
            Finally the resolver tries the normal flow 
            which is using the configuration
            or other component to satisfy the dependency
            </description></item></list></remarks>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="parentResolver">Parent resolver</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>The dependency resolved value or null</returns>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ExtractComponentKey(System.String,System.String)">
      <summary>
            Extracts the component name from the a ref strings which is
            ${something}
            </summary>
      <param name="name">
      </param>
      <param name="keyValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RebuildContextForParameter(Castle.MicroKernel.CreationContext,System.Type)">
      <summary>
            This method rebuild the context for the parameter type.
            Naive implementation.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.DependencyResolverException">
      <summary>
            Summary description for DependencyResolverException.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.ISubSystem">
      <summary>
            A subsystem is used by the MicroKernel to deal 
            with a specific concern.  
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ISubSystem.Init(Castle.MicroKernel.IKernel)">
      <summary>
            Initializes the subsystem
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ISubSystem.Terminate">
      <summary>
            Should perform the termination
            of the subsystem instance.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IConfigurationStore">
      <summary>
            The contract used by the kernel to obtain
            external configuration for the components and
            facilities.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Associates a configuration node with a facility key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Associates a configuration node with a component key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Associates a  configuration node with a bootstrap component key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds the child container configuration.
            </summary>
      <param name="name">The container's name.</param>
      <param name="config">The config.</param>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetChildContainerConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with 
            the specified child container key. Should return null
            if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilityConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with 
            the specified facility key. Should return null
            if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponentConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilities">
      <summary>
            Returns all configuration nodes for facilities
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponents">
      <summary>
            Returns all configuration nodes for components
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetBootstrapComponents">
      <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetConfigurationForChildContainers">
      <summary>
            Gets the child containers configuration nodes.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IConfigurationStore.GetResource(System.String,Castle.Core.Resource.IResource)">
      <summary>
      </summary>
      <param name="resourceUri">
      </param>
      <param name="resource">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore">
      <summary>
            This implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore" />
            does not try to obtain an external configuration by any means.
            Its only purpose is to serve as a base class for subclasses
            that might obtain the configuration node from anywhere.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore" /> class.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Associates a configuration node with a facility key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Associates a configuration node with a component key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Associates a configuration node with a bootstrap component key
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds the child container configuration.
            </summary>
      <param name="key">The key.</param>
      <param name="config">The config.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilityConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with
            the specified facility key. Should return null
            if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetChildContainerConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with
            the specified child container key. Should return null
            if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponentConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with
            the specified component key. Should return null
            if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
      <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilities">
      <summary>
            Returns all configuration nodes for facilities
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponents">
      <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetConfigurationForChildContainers">
      <summary>
            Returns all configuration nodes for child containers
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponents">
      <summary>
            Returns all configuration nodes for components
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter">
      <summary>
            Implements a conversion logic to a type of a
            set of types. 
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type)">
      <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified 
            configuration
            </summary>
      <param name="type">
      </param>
      <param name="configuration">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(System.String,System.Type)">
      <summary>
            Should perform the conversion from the
            string representation specified to the type
            specified.
            </summary>
      <param name="value">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
      <summary>
            Should perform the conversion from the
            configuration node specified to the type
            specified.
            </summary>
      <param name="configuration">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter">
      <summary>
            Base implementation of <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified
            configuration
            </summary>
      <param name="type">
      </param>
      <param name="configuration">
      </param>
      <returns>
      </returns>
      <remarks>
            The default behavior is to just pass it to the normal CanHadnleType
            peeking into the configuration is used for some advanced functionality
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.GenericDictionaryConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.GenericDictionaryConverter" /> class.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.IGenericCollectionConverterHelper">
      <summary>
            This interface is needed because we want to isolate ourself from
            the generic parameters, so we can work type safe inside the implementations,
            and still call from non generic types outside.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.GenericListConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.GenericListConverter" /> class.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.AttributeAwareConverter">
      <summary>
            Looks for a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute" /> on the type to be converted. 
            If found, the TypeConverter defined by the attribute is used to perform the conversion.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter">
      <summary>
            Marker interface that signals that a converter
            depends on IKernel to be able to perform 
            the conversion.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.CreateInstance(System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Creates the target type instance.
            </summary>
      <param name="type">The type.</param>
      <param name="configuration">The configuration.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ChooseConstructor(System.Type)">
      <summary>
            Chooses the first non default constructor. Throws an exception if more than 
            one non default constructor is found
            </summary>
      <param name="type">
      </param>
      <returns>The chosen constructor, or <c>null</c> if none was found</returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertConstructorParameters(System.Reflection.ConstructorInfo,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Converts the constructor parameters.
            </summary>
      <param name="constructor">The constructor.</param>
      <param name="configuration">The configuration.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertPropertyValues(System.Object,System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Converts the property values.
            </summary>
      <param name="instance">The instance.</param>
      <param name="type">The type.</param>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.FindChildIgnoreCase(Castle.Core.Configuration.IConfiguration,System.String)">
      <summary>
            Finds the child (case insensitive).
            </summary>
      <param name="config">The config.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConversionManager">
      <summary>
            Gets the conversion manager.
            </summary>
      <value>The conversion manager.</value>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.EnumConverter">
      <summary>
            Converts a string representation to an enum value
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter">
      <summary>
            Implements all standard conversions.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter">
      <summary>
            Convert a type name to a Type instance.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException">
      <summary>
            Summary description for ConverterException.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute">
      <summary>
            Declares a type as being convertible by a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter" /> and optionally defines the converter to be used
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor">
      <summary>
            Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter" /> to be used to convert the type
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor(System.Type)">
      <summary>
            Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter" /> to be used to convert the type
            </summary>
      <param name="converterType">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.IConversionManager">
      <summary>
            Establish a composition interface and a subsystem.
            Implementors should delegate the conversion to 
            a instance of a type converter.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.IConversionManager.Add(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
      <summary>
            Register a type converter instance.
            </summary>
      <param name="converter">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager">
      <summary>
            Composition of all available conversion managers
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.BinaryTreeComponentName.FindSuccessor(Castle.MicroKernel.SubSystems.Naming.TreeNode)">
      <summary>
            Method finds the next biggest node
            It assumes Add puts lesser nodes on the right
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.left">
      <summary>Node's left</summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.right">
      <summary>Node's right</summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.parent">
      <summary>Node's parent</summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.nextSibling">
      <summary>DA Linked List</summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String)">
      <summary>
            Creates a ComponentName using a name pattern like
            "service:key=value,key2=value2"
            </summary>
      <param name="name">Complete name</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String,System.String)">
      <summary>
            Creates a ComponentName with specified service and 
            properties.
            </summary>
      <param name="service">Service name</param>
      <param name="properties">Property list.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor.
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.Setup(System.String)">
      <summary>
            Parses the full name extracting the service and properties.
            </summary>
      <param name="name">Full name.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupService(System.String)">
      <summary>
            Sets up the service. Can be empty but can't be null.
            </summary>
      <param name="service">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.String)">
      <summary>
            Parses and validate a properties list string like 
            "key=value,key2=value2" and so on.
            </summary>
      <param name="properties">Property list.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.Collections.IDictionary)">
      <summary>
            Validates a properties Hashtable.
            </summary>
      <param name="properties">Property list.</param>
    </member>
    <member name="T:Castle.MicroKernel.INamingSubSystem">
      <summary>
            Contract for SubSystem that wishes to keep and coordinate
            component registration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
      <summary>
            Implementors should register the key and service pointing 
            to the specified handler
            </summary>
      <param name="key">
      </param>
      <param name="handler">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.String)">
      <summary>
            Unregister the handler by the given key
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.Type)">
      <summary>
            Unregister the handler by the given service
            </summary>
      <param name="service">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.String)">
      <summary>
            Returns true if there is a component registered 
            for the specified key
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.Type)">
      <summary>
            Returns true if there is a component registered 
            for the specified service
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String)">
      <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler" /> associated with
            the specified key.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.String)">
      <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler" /> that
            satisfies the specified query.
            </summary>
      <param name="query">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.Type)">
      <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler" /> associated with
            the specified service.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String,System.Type)">
      <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler" /> associated with
            the specified key with the service type.
            <remarks>
            It is expected that this will be used mainly to resolve a generic service
            by its key.
            </remarks></summary>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.Type)">
      <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler" /> associated with
            the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers">
      <summary>
            Returns all <see cref="T:Castle.MicroKernel.IHandler" /> registered.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetAssignableHandlers(System.Type)">
      <summary>
            Return <see cref="T:Castle.MicroKernel.IHandler" />s where components are compatible
            with the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetKey2Handler">
      <summary>
            List of handler by key
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.INamingSubSystem.GetService2Handler">
      <summary>
            List of handler by service
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.INamingSubSystem.ComponentCount">
      <summary>
            Returns the number of components registered.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.Type)">
      <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler" /> with 
            the specified service
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.String)">
      <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler" /> with
            the specified key
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem">
      <summary>
            Default <see cref="T:Castle.MicroKernel.INamingSubSystem" /> implementation.
            Keeps services and key maps as simple hash tables. Does not
            support a query string.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.key2Handler">
      <summary>
            Map(String, IHandler) to map component keys
            to <see cref="T:Castle.MicroKernel.IHandler" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.service2Handler">
      <summary>
            Map(Type, IHandler) to map services 
            to <see cref="T:Castle.MicroKernel.IHandler" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem" /> class.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem">
      <summary>
            When requesting a component by service, KeySearchNamingSubSystem first 
            determines if more than one component has been registered for that service.  
            If not, Default resolution occurs.  If so, all of the registered keys for 
            that service are processed through the provided Predicate to determine which 
            key to use for service resolution.  If no Predicate matches, the default 
            resolution occurs.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem" /> class.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.#ctor(System.Predicate{System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem" /> class.
            </summary>
      <param name="keyPredicate">The key predicate.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
      <summary>
            Registers the given handler with the give key.
            </summary>
      <param name="key">The key.</param>
      <param name="handler">The handler.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.UnRegister(System.String)">
      <summary>
            Unregisters the handler associated with the given key
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.UnRegister(System.Type)">
      <summary>
            Unregisters the handler associated with the given service
            </summary>
      <param name="service">The service.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.GetHandler(System.Type)">
      <summary>
            Executes the Predicate against all keys for the registered service to 
            determine which component to return.
            </summary>
      <param name="service">The service.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Naming.NamingPartsSubSystem">
      <summary>
            Alternative <see cref="T:Castle.MicroKernel.INamingSubSystem" /> implementation.
            Extends the default implementation replacing the 
            key support with a more complete ComponentName. Supports
            queries.
            </summary>
      <example>
            The user must register components using the following construction
            <code>
              service:properties
            </code>
            Where properties is a list of key value pairs (comma separated). Example:
            <code>
              protocol:secure=true,version=1.2
            </code>
            The user can then query for components using the same construction:
            <code>
              protocol:secure=true
            </code>
            Or to return all:
            <code>
              protocol:*
            </code></example>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem">
      <summary>
            An implementation of <c>a</c> should 
            be able to return instances of <see cref="T:Castle.Core.Resource.IResource" />
            for a given resource identifier.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystemConstants">
      <summary>
            Holds the keys used by Kernel to register/request 
            a subsystem.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.ConfigurationStoreKey">
      <summary>
            Key used for the configuration store subsystem
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.ConversionManagerKey">
      <summary>
            Key used for the conversion manager
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.NamingKey">
      <summary>
            Key used for the naming subsystem
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.ResourceKey">
      <summary>
            Key used for the resource subsystem
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Util.ReferenceComparer">
      <summary>
            Compares if the reference of two objects are equals.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Util.ReferenceExpressionUtil">
      <summary>
            Summary description for ReferenceExpressionUtil.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IKernelEvents">
      <summary>
            Summary description for IKernelEvents.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentRegistered">
      <summary>
            Event fired when a new component is registered 
            on the kernel.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentUnregistered">
      <summary>
            Event fired when a component is removed from the kernel.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated">
      <summary>
            Event fired after the ComponentModel is created.
            Allows customizations that may affect the handler.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel">
      <summary>
            Event fired when the kernel was added as child of
            another kernel.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.RemovedAsChildKernel">
      <summary>
            Event fired when the kernel was removed from being a child
            of another kernel.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentCreated">
      <summary>
            Event fired before the component is created.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed">
      <summary>
            Event fired when a component instance destroyed.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered">
      <summary>
            Event fired when a new handler is registered 
            (it might be in a valid or waiting dependency state)
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.DependencyResolving">
      <summary>
            Event fired when a dependency is being resolved,
            it allows the dependency to be changed,
            but the client ComponentModel must not be altered.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.KernelEventSupport">
      <summary>
            Summary description for KernelEventSupport.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.HandlerRegistered">
      <summary>
            Pending
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentRegistered">
      <summary>
            Pending
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentUnregistered">
      <summary>
            Pending
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentCreated">
      <summary>
            Pending
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentDestroyed">
      <summary>
            Pending
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.AddedAsChildKernel">
      <summary>
            Pending
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.RemovedAsChildKernel">
      <summary>
            Pending
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentModelCreated">
      <summary>
            Pending
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.MicroKernel.IKernel">
      <summary>
            The <c>IKernel</c> interface exposes all the functionality
            the MicroKernel implements.
            </summary>
      <remarks>
            It allows you to register components and
            request them by the key or the service they implemented.
            It also allow you to register facilities and subsystem, thus 
            augmenting the functionality exposed by the kernel alone to fits 
            your needs.
            <seealso cref="T:Castle.MicroKernel.IFacility" /><seealso cref="T:Castle.MicroKernel.ISubSystem" /></remarks>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type)">
      <summary>
            Adds a concrete class as a component
            </summary>
      <param name="key">
      </param>
      <param name="classType">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" />, or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
            </exception>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)">
      <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <param name="overwriteLifestyle">
            If <see langword="true" />, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle" /> parameter.
            </param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" /> or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException" />
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
        </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type)">
      <summary>
            Adds a concrete class and an interface 
            as a component
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that this component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that this component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" />, <paramref name="serviceType" />, or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
            </exception>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)">
      <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that this component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <param name="overwriteLifestyle">
            If <see langword="true" />, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle" /> parameter.
            </param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" />, <paramref name="serviceType" />, or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
            </exception>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
            Adds a concrete class as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
      <param name="key">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
      <summary>
            Adds a concrete class and an interface 
            as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
      <param name="key">
      </param>
      <param name="serviceType">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddCustomComponent(Castle.Core.ComponentModel)">
      <summary>
            Adds a custom made <see cref="T:Castle.Core.ComponentModel" />.
            Used by facilities.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Object)">
      <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
      <param name="key">
      </param>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Type,System.Object)">
      <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
      <param name="key">
      </param>
      <param name="serviceType">
      </param>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.RemoveComponent(System.String)">
      <summary>
            Returns true if the specified component was 
            found and could be removed (i.e. no other component depends on it)
            </summary>
      <param name="key">The component's key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.String)">
      <summary>
            Returns true if the specified key was registered
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.Type)">
      <summary>
            Returns true if the specified service was registered
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ResolveServices``1">
      <summary>
            Returns component instances that implement TService
            </summary>
      <typeparam name="TService">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.Type,System.Collections.IDictionary)">
      <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
      <param name="service">
      </param>
      <param name="dependencies">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.String,System.Collections.IDictionary)">
      <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
      <param name="key">
      </param>
      <param name="dependencies">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ReleaseComponent(System.Object)">
      <summary>
            Releases a component instance. This allows
            the kernel to execute the proper decomission 
            lifecycles on the component instance.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.CreateComponentActivator(Castle.Core.ComponentModel)">
      <summary>
            Constructs an implementation of <see cref="T:Castle.MicroKernel.IComponentActivator" />
            for the given <see cref="T:Castle.Core.ComponentModel" /></summary>
      <param name="model">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.String)">
      <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler" />
            for the specified component key.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.Type)">
      <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler" />
            for the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetHandlers(System.Type)">
      <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetAssignableHandlers(System.Type)">
      <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddFacility(System.String,Castle.MicroKernel.IFacility)">
      <summary>
            Adds a <see cref="T:Castle.MicroKernel.IFacility" /> to the kernel.
            </summary>
      <param name="key">
      </param>
      <param name="facility">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetFacilities">
      <summary>
            Returns the facilities registered on the kernel.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddSubSystem(System.String,Castle.MicroKernel.ISubSystem)">
      <summary>
            Adds (or replaces) an <see cref="T:Castle.MicroKernel.ISubSystem" /></summary>
      <param name="key">
      </param>
      <param name="subsystem">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetSubSystem(System.String)">
      <summary>
            Returns an implementation of <see cref="T:Castle.MicroKernel.ISubSystem" />
            for the specified key. 
            <seealso cref="T:Castle.MicroKernel.SubSystemConstants" /></summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddChildKernel(Castle.MicroKernel.IKernel)">
      <summary>
            Support for kernel hierarchy
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.RemoveChildKernel(Castle.MicroKernel.IKernel)">
      <summary>
            Remove child kernel
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Item(System.String)">
      <summary>
            Returns the component instance by the key
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Item(System.Type)">
      <summary>
            Returns the component instance by the service type
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ComponentModelBuilder">
      <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.HandlerFactory">
      <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ConfigurationStore">
      <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ReleasePolicy">
      <summary>
            Gets or sets the implementation for <see cref="T:Castle.MicroKernel.IReleasePolicy" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Resolver">
      <summary>
            Returns the implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ProxyFactory">
      <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" />
            allowing different strategies for proxy creation.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Parent">
      <summary>
            Returns the parent kernel
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.GraphNodes">
      <summary>
            Graph of components and iteractions.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.DefaultKernel">
      <summary>
            Default implementation of <see cref="T:Castle.MicroKernel.IKernel" />. 
            This implementation is complete and also support a kernel 
            hierarchy (sub containers).
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.parentKernel">
      <summary>
            The parent kernel, if exists.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.handlerFactory">
      <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.modelBuilder">
      <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.resolver">
      <summary>
            The dependency resolver.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.releaserPolicy">
      <summary>
            Implements a policy to control component's
            disposal that the usef forgot.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.proxyFactory">
      <summary>
            Holds the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.facilities">
      <summary>
            List of <see cref="T:Castle.MicroKernel.IFacility" /> registered.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.subsystems">
      <summary>
            Map of subsystems registered.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.childKernels">
      <summary>
            List of sub containers.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.#ctor">
      <summary>
            Constructs a DefaultKernel with no component
            proxy support.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IDependencyResolver,Castle.MicroKernel.IProxyFactory)">
      <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" /> and <see cref="T:Castle.MicroKernel.IDependencyResolver" /></summary>
      <param name="resolver">
      </param>
      <param name="proxyFactory">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IProxyFactory)">
      <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" /> or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
            </exception>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)">
      <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <param name="overwriteLifestyle">
            If <see langword="true" />, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle" /> parameter.
            </param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" /> or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException" />
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
        </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that this component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" />, <paramref name="serviceType" />, or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
            </exception>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)">
      <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle" />.
            </summary>
      <param name="key">The key with which to index the component.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that this component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> of the component.</param>
      <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType" /> for the component.</param>
      <param name="overwriteLifestyle">
            If <see langword="true" />, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle" /> parameter.
            </param>
      <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType" /> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)" /> method.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key" />, <paramref name="serviceType" />, or <paramref name="classType" />
            are <see langword="null" />.
            </exception>
      <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle" /> is <see cref="F:Castle.Core.LifestyleType.Undefined" />.
            </exception>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <param name="classType">
      </param>
      <param name="parameters">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <param name="serviceType">
      </param>
      <param name="classType">
      </param>
      <param name="parameters">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddCustomComponent(Castle.Core.ComponentModel)">
      <summary>
      </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Object)">
      <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
      <param name="key">
      </param>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Type,System.Object)">
      <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
      <param name="key">
      </param>
      <param name="serviceType">
      </param>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.RemoveComponent(System.String)">
      <summary>
            Returns true if the specified component was
            found and could be removed (i.e. no other component depends on it)
            </summary>
      <param name="key">The component's key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.GetHandlers(System.Type)">
      <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.GetAssignableHandlers(System.Type)">
      <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.GetFacilities">
      <summary>
            Returns the facilities registered on the kernel.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Dispose">
      <summary>
            Starts the process of component disposal.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.DefaultKernel.GraphNodes">
      <summary>
            Graph of components and iteractions.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentDataDelegate">
      <summary>
            Represents a delegate which holds basic information about a component.
            </summary>
      <param name="key">Key which identifies the component</param>
      <param name="handler">handler that holds this component and is capable of 
            creating an instance of it.
            </param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentInstanceDelegate">
      <summary>
            Represents a delegate which holds basic information about a component
            and its instance.
            </summary>
      <param name="model">Component meta information</param>
      <param name="instance">Component instance</param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentModelDelegate">
      <summary>
            Represents a delegate which holds the information about the 
            component
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.HandlerDelegate">
      <summary>
            Represents a delegate which holds a handler
            </summary>
      <param name="handler">handler that holds a component and is capable of 
            creating an instance of it.
            </param>
      <param name="stateChanged">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.DependencyDelegate">
      <summary>
            Represents a delegate which holds dependency
            resolving information.
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.ITransaction">
      <summary>
            Represents the contract for a transaction.
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.ITransaction.Begin">
      <summary>
            Starts the transaction. Implementors
            should activate the apropriate resources
            in order to start the underlying transaction
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.ITransaction.Commit">
      <summary>
            Succeed the transaction, persisting the
            modifications
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.ITransaction.Rollback">
      <summary>
            Cancels the transaction, rolling back the 
            modifications
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.ITransaction.SetRollbackOnly">
      <summary>
            Signals that this transaction can only be rolledback. 
            This is used when the transaction is not being managed by
            the callee.
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.ITransaction.Enlist(Castle.Services.Transaction.IResource)">
      <summary>
            Register a participant on the transaction.
            </summary>
      <param name="resource">
      </param>
    </member>
    <member name="M:Castle.Services.Transaction.ITransaction.RegisterSynchronization(Castle.Services.Transaction.ISynchronization)">
      <summary>
            Registers a synchronization object that will be 
            invoked prior and after the transaction completion
            (commit or rollback)
            </summary>
      <param name="synchronization">
      </param>
    </member>
    <member name="P:Castle.Services.Transaction.ITransaction.Status">
      <summary>
            Returns the current transaction status.
            </summary>
    </member>
    <member name="P:Castle.Services.Transaction.ITransaction.Context">
      <summary>
            Transaction context. Can be used by applications.
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.AbstractTransaction">
      <summary>
            Helper abstract class for <see cref="T:Castle.Services.Transaction.ITransaction" /> implementors. 
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.Activity.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.Activity" /> class.
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.TransactionMode">
      <summary>
            The supported transaction mode for the components.
            </summary>
    </member>
    <member name="F:Castle.Services.Transaction.TransactionMode.Unspecified">
      <summary>
      </summary>
    </member>
    <member name="F:Castle.Services.Transaction.TransactionMode.NotSupported">
      <summary>
            transaction context will be created 
            managing internally a connection, no 
            transaction is opened though
            </summary>
    </member>
    <member name="F:Castle.Services.Transaction.TransactionMode.Requires">
      <summary>
            transaction context will be created if not present 
            </summary>
    </member>
    <member name="F:Castle.Services.Transaction.TransactionMode.RequiresNew">
      <summary>
            a new transaction context will be created 
            </summary>
    </member>
    <member name="F:Castle.Services.Transaction.TransactionMode.Supported">
      <summary>
            an existing appropriate transaction context 
            will be joined if present
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.IsolationMode">
      <summary>
            The supported isolation modes.
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.TransactionalAttribute">
      <summary>
            Indicates that the target class wants to use
            the transactional services.
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.TransactionAttribute">
      <summary>
            Indicates the transaction support for a method.
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionAttribute.#ctor">
      <summary>
            Declares unspecified values for transaction and isolation, which
            means that the transaction manager will use the default values
            for them
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionAttribute.#ctor(Castle.Services.Transaction.TransactionMode)">
      <summary>
            Declares the transaction mode, but omits the isolation, 
            which means that the transaction manager should use the
            default value for it.
            </summary>
      <param name="transactionMode">
      </param>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionAttribute.#ctor(Castle.Services.Transaction.TransactionMode,Castle.Services.Transaction.IsolationMode)">
      <summary>
            Declares both the transaction mode and isolation 
            desired for this method. The transaction manager should
            obey the declaration.
            </summary>
      <param name="transactionMode">
      </param>
      <param name="isolationMode">
      </param>
    </member>
    <member name="P:Castle.Services.Transaction.TransactionAttribute.TransactionMode">
      <summary>
            Returns the <see cref="P:Castle.Services.Transaction.TransactionAttribute.TransactionMode" /></summary>
    </member>
    <member name="P:Castle.Services.Transaction.TransactionAttribute.IsolationMode">
      <summary>
            Returns the <see cref="P:Castle.Services.Transaction.TransactionAttribute.IsolationMode" /></summary>
    </member>
    <member name="P:Castle.Services.Transaction.TransactionAttribute.Distributed">
      <summary>
            Gets or sets a value indicating whether the transaction should be distributed.
            </summary>
      <value>
        <c>true</c> if a distributed transaction should be created; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Services.Transaction.IActivityManager">
      <summary>
            Abstracts approaches to keep transaction activities
            that may differ based on the environments.
            </summary>
    </member>
    <member name="P:Castle.Services.Transaction.IActivityManager.CurrentActivity">
      <summary>
            Gets the current activity.
            </summary>
      <value>The current activity.</value>
    </member>
    <member name="M:Castle.Services.Transaction.CallContextActivityManager.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.CallContextActivityManager" /> class.
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.CallContextActivityManager.InitializeLifetimeService">
      <summary>
            Obtains a lifetime service object to control the lifetime policy for this instance.
            </summary>
      <returns>
            An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease"></see> used to control the lifetime policy for this instance. This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime"></see> property.
            </returns>
      <exception cref="T:System.Security.SecurityException">The immediate caller does not have infrastructure permission. </exception>
      <filterpriority>2</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="RemotingConfiguration, Infrastructure" />
      </PermissionSet>
    </member>
    <member name="P:Castle.Services.Transaction.CallContextActivityManager.CurrentActivity">
      <summary>
            Gets the current activity.
            </summary>
      <value>The current activity.</value>
    </member>
    <member name="T:Castle.Services.Transaction.ITransactionManager">
      <summary>
            Manages the creation and disposal of <see cref="T:Castle.Services.Transaction.ITransaction" /> instances.
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.ITransactionManager.CreateTransaction(Castle.Services.Transaction.TransactionMode,Castle.Services.Transaction.IsolationMode)">
      <summary>
            Creates a transaction.
            </summary>
      <param name="transactionMode">The transaction mode.</param>
      <param name="isolationMode">The isolation mode.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Services.Transaction.ITransactionManager.CreateTransaction(Castle.Services.Transaction.TransactionMode,Castle.Services.Transaction.IsolationMode,System.Boolean)">
      <summary>
            Creates a transaction.
            </summary>
      <param name="transactionMode">The transaction mode.</param>
      <param name="isolationMode">The isolation mode.</param>
      <param name="distributedTransaction">if set to <c>true</c>, the TM will create a distributed transaction.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Services.Transaction.ITransactionManager.Dispose(Castle.Services.Transaction.ITransaction)">
      <summary>
            Should guarantee the correct disposal of transaction
            resources.
            </summary>
      <param name="transaction">
      </param>
    </member>
    <member name="P:Castle.Services.Transaction.ITransactionManager.CurrentTransaction">
      <summary>
            Returns the current <see cref="T:Castle.Services.Transaction.ITransaction" />. 
            The transaction manager will probably need to 
            hold the created transaction in the thread or in 
            some sort of context.
            </summary>
    </member>
    <member name="E:Castle.Services.Transaction.ITransactionManager.TransactionCreated">
      <summary>
            Raised when a top level transaction was created
            </summary>
    </member>
    <member name="E:Castle.Services.Transaction.ITransactionManager.ChildTransactionCreated">
      <summary>
            Raised when a child transaction was created
            </summary>
    </member>
    <member name="E:Castle.Services.Transaction.ITransactionManager.TransactionCommitted">
      <summary>
            Raised when the transaction was committed successfully
            </summary>
    </member>
    <member name="E:Castle.Services.Transaction.ITransactionManager.TransactionRolledback">
      <summary>
            Raised when the transaction was rolledback successfully
            </summary>
    </member>
    <member name="E:Castle.Services.Transaction.ITransactionManager.TransactionDisposed">
      <summary>
            Raised when the transaction was disposed
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.DefaultTransactionManager">
      <summary>
            TODO: Ensure this class is thread-safe
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.DefaultTransactionManager.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.DefaultTransactionManager" /> class.
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.DefaultTransactionManager.#ctor(Castle.Services.Transaction.IActivityManager)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.DefaultTransactionManager" /> class.
            </summary>
      <param name="activityManager">The activity manager.</param>
    </member>
    <member name="M:Castle.Services.Transaction.DefaultTransactionManager.CreateTransaction(Castle.Services.Transaction.TransactionMode,Castle.Services.Transaction.IsolationMode)">
      <summary>
            Creates a transaction.
            </summary>
      <param name="transactionMode">The transaction mode.</param>
      <param name="isolationMode">The isolation mode.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Services.Transaction.DefaultTransactionManager.CreateTransaction(Castle.Services.Transaction.TransactionMode,Castle.Services.Transaction.IsolationMode,System.Boolean)">
      <summary>
            Creates a transaction.
            </summary>
      <param name="transactionMode">The transaction mode.</param>
      <param name="isolationMode">The isolation mode.</param>
      <param name="distributedTransaction">if set to <c>true</c>, the TM will create a distributed transaction.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Services.Transaction.DefaultTransactionManager.ActivityManager">
      <summary>
            Gets or sets the activity manager.
            </summary>
      <value>The activity manager.</value>
    </member>
    <member name="P:Castle.Services.Transaction.DefaultTransactionManager.Logger">
      <summary>
            Gets or sets the logger.
            </summary>
      <value>The logger.</value>
    </member>
    <member name="T:Castle.Services.Transaction.IResource">
      <summary>
            Represents a contract for a resource that 
            can be enlisted within transactions.
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.IResource.Start">
      <summary>
            Implementors should start the
            transaction on the underlying resource
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.IResource.Commit">
      <summary>
            Implementors should commit the
            transaction on the underlying resource
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.IResource.Rollback">
      <summary>
            Implementors should rollback the
            transaction on the underlying resource
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.ISynchronization">
      <summary>
            Depicts a synchronization contract.
            <para>
            Code can be executed before and after the 
            transaction completes
            </para></summary>
    </member>
    <member name="M:Castle.Services.Transaction.ISynchronization.BeforeCompletion">
      <summary>
            Implementors may have code executing
            just before the transaction completes
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.ISynchronization.AfterCompletion">
      <summary>
            Implementors may have code executing
            just after the transaction completes
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.TransactionStatus">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Services.Transaction.StandardTransaction">
      <summary>
            Implements a transaction root.
            </summary>
    </member>
    <member name="T:Castle.Services.Transaction.ChildTransaction">
      <summary>
            Emulates a standalone transaction but in fact it 
            just propages a transaction. 
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.TransactionException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.TransactionException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.TransactionException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
      <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionScopeResourceAdapter.#ctor(Castle.Services.Transaction.TransactionMode,Castle.Services.Transaction.IsolationMode)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Services.Transaction.TransactionScopeResourceAdapter" /> class.
            </summary>
      <param name="mode">The mode.</param>
      <param name="isolationMode">The isolation mode.</param>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionScopeResourceAdapter.Start">
      <summary>
            Implementors should start the
            transaction on the underlying resource
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionScopeResourceAdapter.Commit">
      <summary>
            Implementors should commit the
            transaction on the underlying resource
            </summary>
    </member>
    <member name="M:Castle.Services.Transaction.TransactionScopeResourceAdapter.Rollback">
      <summary>
            Implementors should rollback the
            transaction on the underlying resource
            </summary>
    </member>
    <member name="T:Castle.Windsor.IContainerAccessor">
      <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <p>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </p></summary>
    </member>
    <member name="T:Castle.Windsor.Adapters.ComponentModel.IContainerAdapter">
      <summary>
            Integrates the <see cref="T:Castle.Windsor.WindsorContainer" /> to the System.ComponentModel
            and System.ComponentMode.Design infrastructure.
            </summary>
      <seealso cref="T:System.ComponentModel.IComponent" />
      <seealso cref="T:System.ComponentModel.IContainer" />
      <seealso cref="T:System.ComponentModel.Design.IServiceContainer" />
    </member>
    <member name="T:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper">
      <summary>
            Implementation of <see cref="T:Castle.Windsor.Adapters.ComponentModel.IContainerAdapter" /> that does not assume ownership of the
            wrapped <see cref="T:Castle.Windsor.IWindsorContainer" />. 
            </summary>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.#ctor(Castle.Windsor.IWindsorContainer)">
      <summary>
            Constructs an initial ContainerWrapper.
            </summary>
      <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer" /> to adapt.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.#ctor(Castle.Windsor.IWindsorContainer,System.IServiceProvider)">
      <summary>
            Constructs an initial ContainerWrapper.
            </summary>
      <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer" /> to adapt.</param>
      <param name="parentProvider">The parent <see cref="T:System.IServiceProvider" />.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Add(System.ComponentModel.IComponent)">
      <summary>
            Adds the specified <see cref="T:System.ComponentModel.IComponent" /> to the <see cref="T:System.ComponentModel.IContainer" /> at the end of the list.
            </summary>
      <param name="component">The <see cref="T:System.ComponentModel.IComponent" /> to add.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Add(System.ComponentModel.IComponent,System.String)">
      <summary>
            Adds the specified <see cref="T:System.ComponentModel.IComponent" /> to the <see cref="T:System.ComponentModel.IContainer" /> at the end of the list,
            and assigns a name to the component.
            </summary>
      <param name="component">The <see cref="T:System.ComponentModel.IComponent" /> to add.</param>
      <param name="name">The unique, case-insensitive name to assign to the component, or null.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Remove(System.ComponentModel.IComponent)">
      <summary>
            Removes a component from the <see cref="T:System.ComponentModel.IContainer" />.
            </summary>
      <param name="component">The <see cref="T:System.ComponentModel.IComponent" /> to remove</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.GetService(System.Type)">
      <summary>
            Gets the service object of the specified type.
            </summary>
      <param name="serviceType">The type of service.</param>
      <returns>An object inplementing service, or null.</returns>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.Object)">
      <summary>
            Adds the specified service to the service container.
            </summary>
      <param name="serviceType">The type of service to add.</param>
      <param name="serviceInstance">The instance of the service to add.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.ComponentModel.Design.ServiceCreatorCallback)">
      <summary>
            Adds the specified service to the service container.
            </summary>
      <param name="serviceType">The type of service to add.</param>
      <param name="callback">A callback object that is used to create the service.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.Object,System.Boolean)">
      <summary>
            Adds the specified service to the service container, and optionally
            promotes the service to any parent service containers.
            </summary>
      <param name="serviceType">The type of service to add.</param>
      <param name="serviceInstance">The instance of the service to add.</param>
      <param name="promote">true to promote this request to any parent service containers.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.AddService(System.Type,System.ComponentModel.Design.ServiceCreatorCallback,System.Boolean)">
      <summary>
            Adds the specified service to the service container, and optionally 
            promotes the service to parent service containers.
            </summary>
      <param name="serviceType">The type of service to add.</param>
      <param name="callback">A callback object that is used to create the service.</param>
      <param name="promote">true to promote this request to any parent service containers.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.RemoveService(System.Type)">
      <summary>
            Removes the specified service type from the service container.
            </summary>
      <param name="serviceType">The type of service to remove.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.RemoveService(System.Type,System.Boolean)">
      <summary>
            Removes the specified service type from the service container, 
            and optionally promotes the service to parent service containers.
            </summary>
      <param name="serviceType">The type of service to remove.</param>
      <param name="promote">true to promote this request to any parent service containers.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.IsIntrinsicService(System.Type)">
      <summary>
            Determins if the service type represents an intrinsic service.
            </summary>
      <param name="serviceType">The type of service to remove.</param>
      <returns>true if the service type is an intrinsic service.</returns>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.HasService(System.Type)">
      <summary>
            Determins if the specified service type exists in the service container.
            </summary>
      <param name="serviceType">The type of service to remove.</param>
      <returns>true if the service type exists.</returns>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Dispose">
      <summary>
            Releases the resources used by the component.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Dispose(System.Boolean)">
      <summary>
            Releases the resources used by the component.
            </summary>
      <param name="disposing">true if disposing.</param>
    </member>
    <member name="P:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Site">
      <summary>
            Gets or sets the <see cref="T:System.ComponentModel.ISite" /> associated with the <see cref="T:System.ComponentModel.IComponent" />.
            </summary>
    </member>
    <member name="P:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Components">
      <summary>
            Gets all the components in the <see cref="T:System.ComponentModel.IContainer" />.
            </summary>
    </member>
    <member name="P:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Container">
      <summary>
            Gets the adapted <see cref="T:Castle.Windsor.IWindsorContainer" /></summary>
    </member>
    <member name="E:Castle.Windsor.Adapters.ComponentModel.ContainerWrapper.Disposed">
      <summary>
            Event that notifies the disposal of the <see cref="T:System.ComponentModel.IComponent" />.
            </summary>
    </member>
    <member name="T:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter">
      <summary>
            Implementation of <see cref="T:Castle.Windsor.Adapters.ComponentModel.IContainerAdapter" /> that assumes ownership of the
            wrapped <see cref="T:Castle.Windsor.IWindsorContainer" />.  If this adapter is disposed, the underlying
            <see cref="T:Castle.Windsor.IWindsorContainer" /> is diposed as well.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor">
      <summary>
            Constructs a default ContainerAdapter.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor(System.IServiceProvider)">
      <summary>
            Constructs a chained ContainerAdapter.
            </summary>
      <param name="parentProvider">The parent <see cref="T:System.IServiceProvider" />.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor(Castle.Windsor.IWindsorContainer)">
      <summary>
            Constructs an initial ContainerAdapter.
            </summary>
      <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer" /> to adapt.</param>
    </member>
    <member name="M:Castle.Windsor.Adapters.ComponentModel.ContainerAdapter.#ctor(Castle.Windsor.IWindsorContainer,System.IServiceProvider)">
      <summary>
            Constructs an initial ContainerAdapter.
            </summary>
      <param name="container">The <see cref="T:Castle.Windsor.IWindsorContainer" /> to adapt.</param>
      <param name="parentProvider">The parent <see cref="T:System.IServiceProvider" />.</param>
    </member>
    <member name="T:Castle.Windsor.Adapters.ComponentModel.ServiceCreatorCallbackActivator">
      <summary>
            Custom activator to create the instance on demand.
            </summary>
    </member>
    <member name="T:Castle.Windsor.Configuration.AppDomain.CastleSectionHandler">
      <summary>
            Implementation of <see cref="T:System.Configuration.IConfigurationSectionHandler" />.
            Do not support configuration inheritance.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.Accept(System.Xml.XmlNode)">
      <summary>
            Accepts the specified node.
            Check if node has the same name as the processor and the node.NodeType
            is in the AcceptNodeTypes List
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.GetNodeAsElement(System.Xml.XmlElement,System.Xml.XmlNode)">
      <summary>
            Convert and return child parameter into an XmlElement
            An exception will be throw in case the child node cannot be converted
            </summary>
      <param name="element">Parent node</param>
      <param name="child">Node to be converted</param>
      <returns>child node as XmlElement</returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AttributesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
      </summary>
      <param name="nodeList">
      </param>
      <param name="engine">
      </param>
      <example>
        <code>
          <properties>
            <attributes>
              <myAttribute>attributeValue</myAttribute>
            </attributes>
            <myProperty>propertyValue</myProperty>
          </properties>
        </code>
      </example>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor.ProcessAttributes(System.Xml.XmlElement,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
            Processes element attributes.
            if the attribute is include will append to the element
            all contents from the file.
            if the attribute has a property reference the reference will be
            expanded
            </summary>
      <param name="element">The element.</param>
      <param name="engine">
      </param>
    </member>
    <member name="F:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.PropertyValidationRegExp">
      <summary>
            Properties names can contain a-zA-Z0-9_. 
            i.e. #!{ my_node_name } || #{ my.node.name }
            spaces are trimmed
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.ProcessString(System.Xml.XmlNode,System.String,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
            Processes the string.
            </summary>
      <param name="node">The node.</param>
      <param name="value">The value.</param>
      <param name="engine">The context.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.IncludeElementProcessor.Accept(System.Xml.XmlNode)">
      <summary>
            Accepts the specified node.
            Check if node has the same name as the processor and the node.NodeType
            is in the AcceptNodeTypes List
            NOTE: since the BatchRegistrationFacility already uses an include
            element we will distringish between both by looking for the presence of an uri attribute
            we should revisit this later by using xml-namespaces
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.PropertiesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
      </summary>
      <param name="nodeList">
      </param>
      <param name="engine">
      </param>
      <example>
        <code>
          <properties>
            <attributes>
              <myAttribute>attributeValue</myAttribute>
            </attributes>
            <myProperty>propertyValue</myProperty>
          </properties>
        </code>
      </example>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine" /> class.
            </summary>
      <param name="environmentName">Name of the environment.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine" /> class.
            </summary>
      <param name="environmentName">Name of the environment.</param>
      <param name="resourceSubSystem">The resource sub system.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessAll(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
      <summary>
            Processes the element.
            </summary>
      <param name="nodeList">The element.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessCurrent(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
      <summary>
            Processes the element.
            </summary>
      <param name="nodeList">The element.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorNodeList.CloneNodeList(System.Xml.XmlNodeList)">
      <summary>
            Make a shallow copy of the nodeList.
            </summary>
      <param name="nodeList">The nodeList to be copied.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor" /> class.
            </summary>
      <param name="environmentName">Name of the environment.</param>
      <param name="resourceSubSystem">The resource sub system.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor" /> class.
            </summary>
    </member>
    <member name="T:Castle.Windsor.Configuration.IConfigurationInterpreter">
      <summary>
            Interpreter of a specific language to describe 
            configuration nodes in a hierachical manner.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.IConfigurationInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.IConfigurationStore)">
      <summary>
            Should obtain the contents from the resource,
            interpret it and populate the <see cref="T:Castle.MicroKernel.IConfigurationStore" />
            accordingly.
            </summary>
      <param name="resource">
      </param>
      <param name="store">
      </param>
    </member>
    <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.EnvironmentName">
      <summary>
            Gets or sets the name of the environment.
            </summary>
      <value>The name of the environment.</value>
    </member>
    <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.Source">
      <summary>
            Exposes the reference to <see cref="T:Castle.Core.Resource.IResource" />
            which the interpreter is likely to hold
            </summary>
    </member>
    <member name="T:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter">
      <summary>
            Provides common methods for those who wants 
            to implement <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /></summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.IConfigurationStore)">
      <summary>
            Should obtain the contents from the resource,
            interpret it and populate the <see cref="T:Castle.MicroKernel.IConfigurationStore" />
            accordingly.
            </summary>
      <param name="resource">
      </param>
      <param name="store">
      </param>
    </member>
    <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.Source">
      <summary>
            Exposes the reference to <see cref="T:Castle.Core.Resource.IResource" />
            which the interpreter is likely to hold
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.EnvironmentName">
      <summary>
            Gets or sets the name of the environment.
            </summary>
      <value>The name of the environment.</value>
    </member>
    <member name="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter">
      <summary>
            Reads the configuration from a XmlFile. Sample structure:
            <code>
            &lt;configuration&gt;
              &lt;facilities&gt;
                &lt;facility id="myfacility"&gt;
                
                &lt;/facility&gt;
              &lt;/facilities&gt;
              
              &lt;components&gt;
                &lt;component id="component1"&gt;
                
                &lt;/component&gt;
              &lt;/components&gt;
            &lt;/configuration&gt;
            </code></summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter" /> class.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter" /> class.
            </summary>
      <param name="filename">The filename.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(Castle.Core.Resource.IResource)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter" /> class.
            </summary>
      <param name="source">The source.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.GetConfigValue(System.String)">
      <summary>
            If a config value is an empty string we return null, this is to keep
            backward compability with old code
            </summary>
    </member>
    <member name="P:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.Kernel">
      <summary>
            Gets or sets the kernel.
            </summary>
      <value>The kernel.</value>
    </member>
    <member name="T:Castle.Windsor.IComponentsInstaller">
      <summary>
            Installs the components and facilities based on the
            information on the configuration store.
            </summary>
    </member>
    <member name="M:Castle.Windsor.IComponentsInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.IConfigurationStore)">
      <summary>
            Perform installation.
            </summary>
      <param name="container">Target container</param>
      <param name="store">Configuration store</param>
    </member>
    <member name="T:Castle.Windsor.Installer.DefaultComponentInstaller">
      <summary>
            Default <see cref="T:Castle.Windsor.IComponentsInstaller" /> implementation.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Installer.DefaultComponentInstaller.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Installer.DefaultComponentInstaller" /> class.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Installer.DefaultComponentInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.IConfigurationStore)">
      <summary>
            Perform installation.
            </summary>
      <param name="container">Target container</param>
      <param name="store">Configuration store</param>
    </member>
    <member name="M:Castle.Windsor.Proxy.AbstractProxyFactory.ObtainInterceptors(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Obtains the interceptors associated with the component.
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
      <returns>interceptors array</returns>
    </member>
    <member name="T:Castle.Windsor.Proxy.DefaultProxyFactory">
      <summary>
            This implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" /> relies 
            on DynamicProxy to expose proxy capabilies.
            </summary>
      <remarks>
            Note that only virtual methods can be intercepted in a 
            concrete class. However, if the component 
            was registered with a service interface, we proxy
            the interface and the methods don't need to be virtual,
            </remarks>
    </member>
    <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.#ctor">
      <summary>
            Constructs a DefaultProxyFactory
            </summary>
    </member>
    <member name="T:Castle.Windsor.Proxy.ProxyComponentInspector">
      <summary>
            Inspects the component configuration looking for information
            that can influence the generation of a proxy for that component.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyComponentInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Seaches for proxy behavior in the configuration and, if unsuccessful
            look for the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" /> attribute in 
            the implementation type.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyComponentInspector.ReadProxyBehaviorFromConfiguration(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            Reads the proxy behavior associated with the 
            component configuration and applies it to the model.
            </summary>
      <exception cref="T:System.Configuration.ConfigurationException">
            If the conversion fails
            </exception>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyComponentInspector.ReadProxyBehaviorFromType(Castle.Core.ComponentModel)">
      <summary>
            Check if the type exposes the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" />.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.Windsor.Proxy.ProxyConstants">
      <summary>
            Holds the keys used by the proxy factories.
            </summary>
    </member>
    <member name="F:Castle.Windsor.Proxy.ProxyConstants.ProxyOptionsKey">
      <summary>
            Key used to supply custom proxy options.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyOptions.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Proxy.ProxyOptions" /> class.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.Proxy.ProxyOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyOptions.AddAdditionalInterfaces(System.Type[])">
      <summary>
            Adds the additional interfaces to proxy.
            </summary>
      <param name="interfaces">The interfaces.</param>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyOptions.Equals(System.Object)">
      <summary>
            Equalses the specified obj.
            </summary>
      <param name="obj">The obj.</param>
      <returns>true if equal.</returns>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyOptions.GetHashCode">
      <summary>
            Gets the hash code.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Windsor.Proxy.ProxyOptions.AdditionalInterfaces">
      <summary>
            Gets the additional interfaces to proxy.
            </summary>
      <value>The interfaces.</value>
    </member>
    <member name="T:Castle.Windsor.Proxy.ProxyUtil">
      <summary>
            Helper support for proxy configuration.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Proxy.ProxyUtil.ObtainProxyOptions(Castle.Core.ComponentModel,System.Boolean)">
      <summary>
            Obtains the <see cref="T:Castle.Windsor.Proxy.ProxyOptions" /> associated with the <see cref="T:Castle.Core.ComponentModel" />.
            </summary>
      <param name="model">The component model.</param>
      <param name="createOnDemand">true if the options should be created if not present.</param>
      <returns>The associated proxy options for the component model.</returns>
    </member>
    <member name="T:Castle.Windsor.IEnvironmentInfo">
      <summary>
            Gets the environment information (name). Implementors should 
            use to define their environments and how those affect the configuration.
            It is also used by the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter" />
            to define a flag with the environment name.
            </summary>
    </member>
    <member name="M:Castle.Windsor.IEnvironmentInfo.GetEnvironmentName">
      <summary>
            Gets the name of the environment.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Windsor.IWindsorContainer">
      <summary>
            The <c>IWindsorContainer</c> interface exposes all the 
            functionality the Windsor implements.
            </summary>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
      <summary>
            Registers a facility within the kernel.
            </summary>
      <param name="key">The key by which the <see cref="T:Castle.MicroKernel.IFacility" /> gets indexed.</param>
      <param name="facility">The <see cref="T:Castle.MicroKernel.IFacility" /> to add to the container.</param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddComponent(System.String,System.Type)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">The key by which the component gets indexed.</param>
      <param name="classType">The <see cref="T:System.Type" /> to manage.</param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddComponent(System.String,System.Type,System.Type)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">The key by which the component gets indexed.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that the component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> to manage.</param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddComponentWithLifestyle(System.String,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">The key by which the component gets indexed.</param>
      <param name="classType">The <see cref="T:System.Type" /> to manage.</param>
      <param name="lifestyle">The <see cref="T:Castle.Core.LifestyleType" /> with which to manage the component.</param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddComponentWithLifestyle(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">The key by which the component gets indexed.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that the component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> to manage.</param>
      <param name="lifestyle">The <see cref="T:Castle.Core.LifestyleType" /> with which to manage the component.</param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddComponentWithProperties(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
            Adds a concrete class as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
      <param name="key">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddComponentWithProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
      <summary>
            Adds a concrete class and an interface 
            as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
      <param name="key">
      </param>
      <param name="serviceType">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type)">
      <summary>
            Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Release(System.Object)">
      <summary>
            Releases a component instance
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
            Registers a subcontainer. The components exposed
            by this container will be accessible from subcontainers.
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
            Remove a child container
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.GetChildContainer(System.String)">
      <summary>
            Gets a child container instance by name.
            </summary>
      <param name="name">The container's name.</param>
      <returns>The child container instance or null</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1">
      <summary>
            Returns a component instance by the service
            </summary>
      <typeparam name="T">Service type</typeparam>
      <returns>The component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the service
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="arguments">
      </param>
      <returns>The component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">Component's key</param>
      <typeparam name="T">Service type</typeparam>
      <returns>The Component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the key
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="key">Component's key</param>
      <param name="arguments">
      </param>
      <returns>The Component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Name">
      <summary>
            Gets the container's name
            </summary>
      <remarks>
            Only useful when child containers are being used
            </remarks>
      <value>The container's name.</value>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Item(System.String)">
      <summary>
            Shortcut to <see cref="M:Castle.Windsor.IWindsorContainer.Resolve(System.String)" /></summary>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Item(System.Type)">
      <summary>
            Shortcut to <see cref="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type)" /></summary>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Kernel">
      <summary>
            Returns the inner instance of the MicroKernel
            </summary>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Parent">
      <summary>
            Gets or sets the parent container if this instance
            is a sub container.
            </summary>
    </member>
    <member name="T:Castle.Windsor.WindsorContainer">
      <summary>
            Implementation of <see cref="T:Castle.Windsor.IWindsorContainer" />
            which delegates to <see cref="T:Castle.MicroKernel.IKernel" /> implementation.
            </summary>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor">
      <summary>
            Constructs a container without any external 
            configuration reference
            </summary>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IConfigurationStore)">
      <summary>
            Constructs a container using the specified 
            <see cref="T:Castle.MicroKernel.IConfigurationStore" /> implementation.
            </summary>
      <param name="store">The instance of an <see cref="T:Castle.MicroKernel.IConfigurationStore" /> implementation.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
      <summary>
            Constructs a container using the specified 
            <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /> implementation.
            </summary>
      <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /> implementation.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter,Castle.Windsor.IEnvironmentInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer" /> class.
            </summary>
      <param name="interpreter">The interpreter.</param>
      <param name="environmentInfo">The environment info.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer" /> class using a
            xml file to configure it.
            <para>
            Equivalent to the use of <c>new WindsorContainer(new XmlInterpreter(xmlFile))</c></para></summary>
      <param name="xmlFile">The XML file.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
      <summary>
            Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel" />
            implementation. Rarely used.
            </summary>
      <remarks>
            This constructs sets the Kernel.ProxyFactory property to
            <see cref="T:Castle.Windsor.Proxy.DefaultProxyFactory" /></remarks>
      <param name="kernel">Kernel instance</param>
      <param name="installer">Installer instance</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
      <summary>
            Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel" />
            implementation. Rarely used.
            </summary>
      <remarks>
            This constructs sets the Kernel.ProxyFactory property to
            <see cref="T:Castle.Windsor.Proxy.DefaultProxyFactory" /></remarks>
      <param name="name">Container's name</param>
      <param name="kernel">Kernel instance</param>
      <param name="installer">Installer instance</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IProxyFactory)">
      <summary>
            Constructs with a given <see cref="T:Castle.MicroKernel.IProxyFactory" />.
            </summary>
      <param name="proxyFactory">A instance of an <see cref="T:Castle.MicroKernel.IProxyFactory" />.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
      <summary>
            Constructs a container assigning a parent container 
            before starting the dependency resolution.
            </summary>
      <param name="parent">The instance of an <see cref="T:Castle.Windsor.IWindsorContainer" /></param>
      <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /> implementation</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer" /> class.
            </summary>
      <param name="name">The container's name.</param>
      <param name="parent">The parent.</param>
      <param name="interpreter">The interpreter.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
      <summary>
            Registers a facility within the kernel.
            </summary>
      <param name="key">
      </param>
      <param name="facility">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddComponent(System.String,System.Type)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">
      </param>
      <param name="classType">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddComponent(System.String,System.Type,System.Type)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">
      </param>
      <param name="serviceType">
      </param>
      <param name="classType">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddComponentWithLifestyle(System.String,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">The key by which the component gets indexed.</param>
      <param name="classType">The <see cref="T:System.Type" /> to manage.</param>
      <param name="lifestyle">The <see cref="T:Castle.Core.LifestyleType" /> with which to manage the component.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddComponentWithLifestyle(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Adds a component to be managed by the container
            </summary>
      <param name="key">The key by which the component gets indexed.</param>
      <param name="serviceType">The service <see cref="T:System.Type" /> that the component implements.</param>
      <param name="classType">The <see cref="T:System.Type" /> to manage.</param>
      <param name="lifestyle">The <see cref="T:Castle.Core.LifestyleType" /> with which to manage the component.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type)">
      <summary>
            Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the service 
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1">
      <summary>
            Returns a component instance by the service 
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Release(System.Object)">
      <summary>
            Releases a component instance
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
            Registers a subcontainer. The components exposed
            by this container will be accessible from subcontainers.
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
            Removes (unregisters) a subcontainer.  The components exposed by this container
            will no longer be accessible to the child container.
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.GetChildContainer(System.String)">
      <summary>
            Gets a child container instance by name.
            </summary>
      <param name="name">The container's name.</param>
      <returns>The child container instance or null</returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Dispose">
      <summary>
            Executes Dispose on underlying <see cref="T:Castle.MicroKernel.IKernel" /></summary>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Name">
      <summary>
            Gets the container's name
            </summary>
      <remarks>
            Only useful when child containers are being used
            </remarks>
      <value>The container's name.</value>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Kernel">
      <summary>
            Returns the inner instance of the MicroKernel
            </summary>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Parent">
      <summary>
            Gets or sets the parent container if this instance
            is a sub container.
            </summary>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Item(System.String)">
      <summary>
            Shortcut to the method <see cref="M:Castle.Windsor.WindsorContainer.Resolve(System.String)" /></summary>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Item(System.Type)">
      <summary>
            Shortcut to the method <see cref="M:Castle.Windsor.WindsorContainer.Resolve(System.Type)" /></summary>
    </member>
  </members>
</doc>